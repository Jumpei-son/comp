module mod_timeseries
  !
  ! tools for handling time series data
  !
  implicit none

  private
  public :: timeseries, timeseries_read, timeseries_interp

  type :: timeseries
    real, allocatable :: time(:)
    real, allocatable :: vars(:,:)
    integer :: nt, nv, i_curr
  end type timeseries

contains

  subroutine count_elements(input, nel)

    character(len=*), intent(in) :: input
    integer, intent(out) :: nel

    character(len=512) :: temp
    integer :: i, len_input

    len_input = len_trim(input)
    temp = adjustl(input)

    nel = 0
    do i = 1, len_input
      if (temp(i:i) == ' ') then
        if (i > 1 .and. temp(i-1:i-1) /= ' ') nel = nel + 1
      endif
    enddo

    if (len_trim(temp) > 0 .and. temp(len_input:len_input) /= ' ') &
      nel = nel + 1

  end subroutine count_elements


  subroutine timeseries_read(fname, data)

    character(len=*), intent(in) :: fname
    type(timeseries), intent(out) :: data

    integer :: i, nt, nv, ios
    real, allocatable :: tmp(:)
    character(len=512) :: line

    ! count numbers of variables
    open(unit=10, file=trim(fname), status='old', action='read')
    read(10, '(a)', iostat=ios) ! skip header
    read(10, '(a)', iostat=ios) line
    if (ios /= 0) then
      print *, 'Error: cannot read ', fname
      stop
    endif

    call count_elements(line, nv)
    nv = nv - 1  ! because of the left column is time
    rewind(10)

    ! count numbers of steps
    nt = 0
    do
      read(10, *, iostat=ios)
      if (ios /= 0) exit
      nt = nt + 1
    enddo
    nt = nt - 1 ! because of one line header
    rewind(10)

    ! allocate arrays
    allocate (data%time(nt), data%vars(nt,nv))

    ! read data and store in timeseries
    data%i_curr = 1
    data%nt = nt
    data%nv = nv

    allocate (tmp(nv+1))
    read(10,*) ! skip header
    do i=1, nt
      read(10,*) tmp
      data%time(i) = tmp(1)
      data%vars(i,:) = tmp(2:)
    enddo
    deallocate (tmp)

    close(10)

  end subroutine timeseries_read


  subroutine timeseries_interp(data, time_interp, data_interp)

    implicit none
    type(timeseries), intent(inout) :: data
    real, intent(in) :: time_interp
    real, intent(out) :: data_interp(:)

    real :: w_
    integer :: i, j

    if (time_interp < data%time(1) .or. time_interp > data%time(data%nt)) then
      print *, 'error: current time is out of range of time series data'
      stop
    endif

    do i=data%i_curr, data%nt - 1
      if (data%time(i) <= time_interp .and. &
        time_interp <= data%time(i+1)) exit
    enddo

    data%i_curr = i

    w_ = (data%time(i+1) - time_interp)/(data%time(i+1) - data%time(i))

    do j=1, data%nv
      data_interp(j) = w_*data%vars(i,j) + (1.0-w_)*data%vars(i+1,j)
    enddo

  end subroutine timeseries_interp

end module mod_timeseries


module mod_parameter
  !
  ! constant parameters
  !
  implicit none

  ! math constant
  real, parameter :: pi=4*atan(1.0)

  ! physical constant
  real, parameter ::      &
    gravity=9.81,         & ! gravitational acceleration, m/s2
    k_boltzmann=1.171e-6    ! Stefan Boltzmann's constant, kcal/m2/day/K4

  ! water
  real, parameter ::  &
    rho_water=998.20, &  ! reference water density(20 deg-C), kg/m3
    mu_water=1.00e-3, &  ! reference water viscosity(20 deg-C), Pa s
    c_water=1.0,      &  ! specific heat at constant pressure, kcal/kg/K
    l_vapor=595.         ! latent heat of water evaporation, kcal/kg

  ! suspended solid particle
  integer :: nps         ! number of particle size
  real :: rho_ss=1650.   ! supended solid particle density, kg/m3
  real, allocatable, dimension(:) :: &
    d_ss,             &  ! particle sizes, m/s
    w_ss                 ! settling velocity for each particle sizes, m/s

#ifdef WQ
  integer :: nwq=14      ! number of water quality variables
#endif
#ifdef TRACER
  integer :: ntr         ! number of tracer fields
  logical, allocatable, dimension(:) :: &
    age                  ! water age(=T) or not(=F)
#endif

contains

  real function water_density(t)
    ! water density, kg/m3
    real, intent(in) :: t ! temperature, deg-C
    water_density = 0.0000400*t**3 - 0.00784*t**2 &
      + 0.0581700*t + 999.85497
  end function water_density

  real function water_viscosity(t)
    ! water viscosity, Pa s
    real, intent(in) :: t ! temperature, deg-C
    water_viscosity = 4.486e-7*t**2 - 4.597e-5*t + 0.00175574
  end function water_viscosity

  real function water_thermal_conductivity(t)
    ! water viscosity, Pa s
    real, intent(in) :: t ! temperature, deg-C
    water_thermal_conductivity = 4.1e-8*t**4 &
      - 5.2e-6*t**3 + 0.00021*t**2 - 0.00177*t + 0.58176
  end function water_thermal_conductivity


  real function turbid_density(t, c)
    ! turbid(mixture) water density, kg/m3
    real, intent(in) :: t ! temperature, deg-C
    real, intent(in) :: c ! suspended solids conc., g/m3
    real :: rho
    rho = water_density(t)
    turbid_density = rho + c/1000*(1. - rho/rho_ss)    
  end function turbid_density


  real function psat(t)
    ! saturation vapour pressure, mmHg
    real, intent(in) :: t    ! temperature, deg-C

    ! from KCC code
    !psat = 0.00045*t**3 + 0.00363*t**2 + 0.39636*t + 4.47110

    ! Murray (1966)
    ! F. W. Murray, On the computation of saturation vapor pressure, 
    ! Journal of Applied Meteorology, vol.6, pp.203-204. (1966)
    psat = 6.1078*exp(17.2693882*t/(t + 237.3)) ! mb
    psat = psat * 0.75006 ! mmHg
 
  end function psat

end module mod_parameter


module mod_domain
  !
  ! module for domain
  !
  use mod_timeseries, only : timeseries

  implicit none

  type :: domain

    !-- domin

    character(len=128) :: name      ! domain name (ex. 'd01', 'd02', ..)
    integer :: id=0                 ! domain id (= 1, 2, 3, ..)
    character(len=128) :: fname_nml ! namelist file of domain (ex. namelist.d01)

    !-- geometric variables

    integer :: nx, nz ! number of cells

    real, pointer, dimension(:) :: &
      x, z,      & ! axis of cell faces, m
      xc, zc,    & ! axis of cell centers, m
      dx, dz,    & ! cell size, m
      dxs, dzs,  & ! dx at u-position, dz at w-position, m
      z_bed        ! bed elevation, m

    real, pointer, dimension(:,:) :: &
      b,         & ! resevoir width, m
      au,        & ! cell face area at u-position, m
      aw,        & ! cell face area at w-position, m2
      aus,       & ! au at cell center, m2
      aws,       & ! aw at cell vertex, m2
      vol,       & ! cell volume, m3
      vols         ! cell volume at u-position, m3

    ! original variables dependent on water surface elevation
    real, pointer, dimension(:) :: &
      dz0,       & ! cell size, m
      dzs0         ! dx at u-position, dz at w-position, m
    !
    real, pointer, dimension(:,:) :: &
      au0,       & ! cell face area at u-position, m
      aw0,       & ! cell face area at w-position, m2
      aus0,      & ! au at cell center, m2
      aws0,      & ! aw at cell vertex, m2
      vol0,      & ! cell volume, m3
      vols0        ! cell volume at u-position, m3

    real, pointer, dimension(:) :: &
      vol_hgt,   & ! total volume with respect to height, m3
      area_hgt,  & ! surface area with respect to height, m2
      len_hgt,   & ! reservoir length with respect to height, m
      vol_lay      ! volume of each layers, m3

    integer, pointer, dimension(:) :: &
      k_bot,     & ! bottom k at cell face
      kc_bot       ! bottom k at cell center

    ! variables related to water surface
    integer :: k_srf   ! index k of the surface layer
    real :: z_srf      ! water surface height, m
    real :: w_srf      ! vertical velocity at water surface, m/s
    real :: dz_srf     ! depth of the surface layer, m
    real :: total_vol  ! total water volume, m3
    real :: q_total_vol! flowrate due to water surface level fluctuations, m3/s

    !-- primary variables

    real, pointer, dimension(:,:) :: &
      u,      &  ! horizontal velocity, m/s
      w,      &  ! vertical velocity, m/s
      p,      &  ! pressure, Pa
      t          ! temperature, deg-C

    real, pointer, dimension(:,:,:) :: &
      s          ! concentraion of suspended solids, g/m3 (=mg/l)

    !-- model variavles

    real, pointer, dimension(:,:) :: &
      rho        ! water density, kg/m3

    real, pointer, dimension(:) :: &
      rho_avg    ! horizontary averaged water density at w-pos, kg/m3

    real, pointer, dimension(:,:) :: &
      s_sed      ! sedimentation rate of suspended solids, g/s

    real :: &
      dmx0,  &  ! coeff of dmx, 1/day
      dmz0,  &  ! coeff of dmz, 1/day
      dhx0,  &  ! coeff of dhx, 1/day
      dhz0,  &  ! coeff of dhz, 1/day
      dcx0,  &  ! coeff of dcx, 1/day
      dcz0,  &  ! coeff of dcz, 1/day
      ll,    &  ! strength param of the expornent
      mm,    &  ! strength param of the expornent
      nn,    &  ! strength param of the expornent
      dmix      ! vertical diffusivity of mixing zone, m2/s

    real, pointer, dimension(:,:) :: &
      dmx,  &  ! horizontal eddy viscosity, m2/s
      dmz,  &  ! vertical eddy viscosity, m2/s
      dhx,  &  ! horizontal eddy diffusivity of heat, m2/s
      dhz,  &  ! vertical eddy diffusivity of heat, m2/s
      dcx,  &  ! horizontal eddy diffusivity of conc., m2/s
      dcz      ! vertical eddy diffusivity of conc., m2/s

    !-- boundary conditions

    ! column flowrate
    real, pointer :: q_col(:)

    ! notes: 
    !   internal Froude number is 0.25 for 2d-flow, 
    !   0.134 for axisymmetric flow, 0.324 for surface and bottom layer flow

    ! inlet flow
    integer :: id_up      ! domain id of upstream (=0: read from fname_in)
    real ::          &
      q_in,          &    ! inlet flowrate, m3/s
      t_in,          &    ! inlet temperature, deg-C
      rho_in,        &    ! inlet density, kg/m3
      z_in,          &    ! median level of inlet flow, m
      delta_in,      &    ! depth of inlet flow, m
      fr_in,         &    ! internal Froude number of inflow
      b_in,          &    ! inflow width, m
      z_in_low         ! lower limit of inflow elevation, m
    real, pointer :: &
      s_in(:)             ! inlet SS concentration, g/m3
    type(timeseries), pointer :: &
      ts_in               ! time series of inlet
    integer, pointer :: &
      i_inlet(:)          ! index i of inlet face
    real :: qtot_in       ! total flowrate at inlet

    ! outlet flow
    integer :: n_out      ! number of outlets
    logical, pointer :: &
      surf_outs(:)        ! outlet at water surface(=T) or in-water(=F)
    real, pointer :: &
      q_outs(:),     &    ! outlet flowrates
      t_outs(:),     &    ! outlet temperature, deg-C
      s_outs(:,:),   &    ! outlet SS concentration, kg/m3
      z_outs(:),     &    ! median level of outlet flow, m
      fr_outs(:),    &    ! internal Froude number of outflow
      phi_outs(:)         ! outflow width, m
    type(timeseries), pointer :: &
      ts_out              ! time series of outlets
    real, pointer :: &
      t_out, s_out(:)     ! averaged values
    real :: qtot_out      ! total flowrate at outlet

    ! cnfluence
    integer :: n_cnf      ! number of confluences
    integer, pointer :: &
      id_cnfs(:)          ! domain id of confluence connections
    real, pointer :: &
      q_cnfs(:),     &    ! confluence flowrate, m3/s
      t_cnfs(:),     &    ! confluence temperature, deg-C
      s_cnfs(:,:),   &    ! confluence SS concentration, g/m3
      theta_cnfs(:)       ! confluence injection angle, deg
    integer, pointer :: &
      i_cnfs(:)           ! index i of confluences
    real, pointer :: &
      q_cnf(:,:),    &    ! q in x-z space, m3/s
      u_cnf(:,:),    &    ! u in x-z space, m/s
      t_cnf(:,:),    &    ! t in x-z space, deg-C
      s_cnf(:,:,:)        ! c in x-z space, g/m3
    real :: qtot_cnf      ! total flowrate of confluences

    ! water pipe flow
    integer :: n_wtp      ! number of water pipes
    integer, pointer :: &
      id_wtps(:)          ! domain id of water pipe connections
    real, pointer :: &
      q_wtps(:),     &    ! water pipe flowrate
      t_wtps(:),     &    ! water pipe temperature
      s_wtps(:,:),   &    ! water pipe SS concentration, g/m3
      fr_wtps(:),    &    ! internal Froude number of water pipe flow
      phi_wtps(:),   &    ! aperture angle of water pipe, deg
      theta_wtps(:), &    ! water pipe injection angle
      z_wtps(:)           ! median level of pipe flow, m
    type(timeseries), pointer :: &
      ts_wtps(:)          ! time series of water pipes
    integer, pointer :: &
      i_wtps(:)           ! index i of water pipes
    real, pointer :: &
      q_wtp(:,:),    &    ! q in x-z space
      u_wtp(:,:),    &    ! u in x-z space
      t_wtp(:,:),    &    ! t in x-z space
      s_wtp(:,:,:)        ! c in x-z space
    real :: qtot_wtp      ! total flowrate of water pipes

    ! point in-out
    integer :: n_pio      ! number of point in-out
    logical, pointer :: &
      trib_pios(:)        ! tributary fow (=T) or not (=F)
    real, pointer :: &
      q_pios(:),     &    ! in-out flowrate
      t_pios(:),     &    ! in-out temperature
      s_pios(:,:),   &    ! in-out SS concentration, g/m3
      fr_pios(:),    &    ! internal Froude number of point in-out flow
      phi_pios(:),   &    ! aperture angle in deg or tributary width when trib_pios=T, deg
      theta_pios(:), &    ! flow angle of point in-out
      z_pios(:)           ! median level of point in-out, m
    type(timeseries), pointer :: &
      ts_pios(:)          ! time series of point in-out
    integer, pointer :: &
      i_pios(:),     &    ! index i of point in-out
      k_pios(:)           ! index k of point in-out
    real, pointer :: &
      q_pio(:,:),    &    ! q in x-z space
      u_pio(:,:),    &    ! u in x-z space
      t_pio(:,:),    &    ! t in x-z space
      s_pio(:,:,:)        ! c in x-z space
    real :: qtot_pio      ! total flowrate of point in-out

    ! fence
    integer :: n_fnc      ! number of fences
    logical, pointer :: &
      type_fncs(:)        ! fence type (=T: floating, =F: fixed at bed)
    real, pointer ::    &
      width_fncs(:)       ! fence width
    integer, pointer :: &
      i_fncs(:),        & ! i-indices of fences
      k_fncs(:,:)         ! k-indices of fences

    !-- probe

    integer :: n_prb      ! number of probing points
    integer, pointer :: &
      i_prb(:),         & ! index i of probes, m
      k_prb(:)            ! index k of probes, m
    real, pointer ::    &
      x_prb(:),         & ! x of probes, m
      z_prb(:)            ! z of probes, m, (negative value is water surface)

#ifdef WQ
    real, pointer ::    & ! water quality variables
      wq_in(:),         & ! inlet
      wq_out(:),        & ! outlet
      wq(:,:,:),        & ! wq in x-z space
      wq_outs(:,:),     & ! outlet
      wq_cnfs(:,:),     & ! confluence
      wq_cnf(:,:,:),    & ! confluence in x-z space
      wq_wtps(:,:),     & ! water pipe
      wq_wtp(:,:,:),    & ! water pipe in x-z space
      wq_pios(:,:),     & ! point in-out
      wq_pio(:,:,:)       ! point in-out in x-z space

    !-- oxygen
    !  1, O  (DO)      dissolved oxygen, g/m3
    !  2, DC (D-COD)   dissolved COD, g/m3
    !  3, C  (C-COD)   detritus COD, g/m3
    !  4, SC (S-COD)   river-derived suspended COD, g/m3
    !-- phosphorus
    !  5, P  (IP)      phosphate phosphorus, mg/m3
    !  6, D  (OP)      detritus phosphorus, mg/m3
    !  7, SP (O-SP)    river-derived organic phosphorus, mg/m3
    !-- nitrogen
    !  8, N  (IN)      inorganic nitrogen, g/m3
    !  9, E  (ON)      detritus nitrogen, g/m3
    ! 10, SN (O-SN)    river-derived organic nitrogen, g/m3
    !-- phytoplankton
    ! 11, Y1 (Y1)      phytoplankton-1, mg/m3
    ! 12, Y2 (Y2)      phytoplankton-2, mg/m3
    ! 13, Y3 (Y3)      phytoplankton-3, mg/m3
    !-- zoo plankton
    ! 14, Z  (Z)       zoo plankton, g/m3

    real, pointer, dimension(:,:) :: &
      wq_sed      ! sedimentation rate of wq, g/s or mg/s
#endif

#ifdef TRACER
    real, pointer ::    &
      tr_in(:),         &  ! inlet
      tr_out(:),        &  ! outlet
      tr(:,:,:),        &  ! tr in x-z space
      tr_outs(:,:),     &  ! outlet
      tr_cnfs(:,:),     &  ! confluence
      tr_cnf(:,:,:),    &  ! confluence in x-z space
      tr_wtps(:,:),     &  ! water pipe
      tr_wtp(:,:,:),    &  ! water pipe in x-z space
      tr_pios(:,:),     &  ! point in-out
      tr_pio(:,:,:)        ! point in-out in x-z space
#endif

  end type domain

  ! all domains
  type(domain), pointer :: doms(:)


contains

  subroutine set_geometry(dom)
    !
    ! input  : fname_geo
    ! output : x, z, z_bed, b, 
    !          xc, zc, dx, dz, dxs, dzs, au, aw, aus, aws, vol, vols,
    !          vol_hgt, area_hgt, len_hgt, k_bot, kc_bot,
    !          dz0, dzs0, au0, aw0, aus0, aws0, vol0, vols0
    !
    implicit none

    type(domain), intent(inout) :: dom

    integer :: nx, nz
    real, pointer, dimension(:) :: x, z, xc, zc, dx, dz, dxs, dzs, z_bed
    real, pointer, dimension(:,:) :: b, au, aw, aus, aws, vol, vols
    real, pointer, dimension(:) :: dz0, dzs0
    real, pointer, dimension(:,:) :: au0, aw0, aus0, aws0, vol0, vols0
    real, pointer, dimension(:) :: vol_hgt, area_hgt, len_hgt, vol_lay
    integer, pointer, dimension(:) :: k_bot, kc_bot

#ifdef V1D
    ! temporary arrays for vertical 1d mode
    logical, allocatable :: east(:,:)
    integer, allocatable :: i_inlet(:)
    real, pointer, dimension(:) :: x1, z_bed1, xc1, dx1, dxs1
    real, pointer :: b1(:,:)
    real, pointer, dimension(:,:) :: au1, aw1, aus1, aws1, vol1, vols1
    integer, pointer, dimension(:) :: k_bot1, kc_bot1
    real, pointer, dimension(:,:) :: au01, aw01, aus01, aws01, vol01, vols01
#endif

    integer :: i, k
    real :: tmp

    character(len=128) :: fname_geo=''
    namelist /geometry/ fname_geo

    ! loading from namelist file
    open(10, file=trim(dom%fname_nml), status='old')
    read(10, nml=geometry)
    close(10)

    write(6, '(a)') trim(dom%name)
    write(6, nml=geometry)

    !-- loading geometric data --
    open(10, file=trim(fname_geo), status='old')

    read(10,*)
    read(10,*) nx, nz

    allocate(x(0:nx), z(0:nz), z_bed(0:nx), b(0:nx,0:nz))

    read(10,*)
    read(10,*)

    do i=0, nx
      read(10,*) x(i), z_bed(i)
    enddo

    read(10,*)
    read(10,*)

    do k=0, nz
      read(10,*) z(k)
    enddo

    read(10,*)
    read(10,*)

    do k=0, nz
      read(10,*) (b(i,k), i=0, nx)
    enddo

    close(10)

    do i=0, nx
      tmp = 0.0
      do k=nz, 0, -1
        if (z(k) >= z_bed(i)) tmp = b(i,k)
        if (z(k) < z_bed(i)) b(i,k) = tmp 
      enddo
    enddo
    !---------------------

    allocate ( &
      xc(nx), zc(nz), &
      dx(nx), dz(nz), dxs(nx-1), dzs(nz-1), &
      au(0:nx,nz), aw(nx,0:nz), aus(nx,nz), aws(nx-1,0:nz), &
      vol(nx,nz), vols(nx-1,nz), vol_hgt(0:nz), & 
      area_hgt(0:nz), len_hgt(0:nz), vol_lay(nz), &
      k_bot(0:nx), kc_bot(nx))

    allocate (dz0(nz), dzs0(nz-1), &
      au0(0:nx,nz), aw0(nx,0:nz), aus0(nx,nz), aws0(nx-1,0:nz), &
      vol0(nx,nz), vols0(nx-1,nz))

    ! cell center position, cell size 
    do i=1, nx
      xc(i) = (x(i) + x(i-1))/2
      dx(i) = x(i) - x(i-1)
    enddo

    do i=1, nx-1
      dxs(i) = (dx(i) + dx(i+1))/2
    enddo

    do k=1, nz
      zc(k) = (z(k) + z(k-1))/2
      dz(k) = z(k) - z(k-1)
    enddo

    do k=1, nz-1
      dzs(k) = (dz(k) + dz(k+1))/2
    enddo

    ! cell face area at u-formation
    do i=0, nx
      do k=1, nz
        au(i,k) = (b(i,k-1) + b(i,k))/2 * dz(k)
      enddo
    enddo

    ! cell face area at w-formation
    do i=1, nx
      do k=0, nz
        aw(i,k) = (b(i-1,k) + b(i,k))/2 * dx(i)
      enddo
    enddo

    ! cell face area at u-stag
    do i=1, nx
      do k=1, nz
        aus(i,k) = (au(i-1,k) + au(i,k))/2
      enddo
    enddo

    ! cell face area at w-stag
    do i=1, nx-1
      do k=0, nz
        aws(i,k) = (aw(i,k) + aw(i+1,k))/2
      enddo
    enddo

    ! cell volume
    do i=1, nx
      do k=1, nz
        vol(i,k) = (aw(i,k-1) + aw(i,k))/2 * dz(k)
      enddo
    enddo

    ! cell volume at u-formation
    do i=1, nx-1
      do k=1, nz
        vols(i,k) = (vol(i,k) + vol(i+1,k))/2
      enddo
    enddo

    ! bottom k at cell face
    do i=0, nx
      k_bot(i) = 1
      do k=2, nz
        if (zc(k-1) <= z_bed(i) .and. z_bed(i) <= zc(k)) &
          k_bot(i) = k
      enddo
    enddo

    ! bottom k at cell center
    do i=1, nx
      kc_bot(i) = 1
      do k=1, nz
        kc_bot(i) = min(k_bot(i-1), k_bot(i))
      enddo
      if (i==nx) k_bot(nx) = kc_bot(nx) !!!
    enddo

    ! layer volume
    vol_lay(:) = 0.
    do i=1, nx
      do k=kc_bot(i), nz
        vol_lay(k) = vol_lay(k) + vol(i,k)
      enddo
    enddo

    ! total water volume with respect to height
    vol_hgt(0) = 0.
    do k=1, nz
      vol_hgt(k) = vol_hgt(k-1) + vol_lay(k)
    enddo

    ! surface area with respect to height
    area_hgt = 0.
    do i=1, nx
      do k=kc_bot(i)-1, nz
        area_hgt(k) = area_hgt(k) + aw(i,k)
      enddo
    enddo

    ! total length with respect to height
    len_hgt(:) = x(nx)

    do k=0, minval(k_bot)
      len_hgt(k) = 0.
    enddo

    do k=minval(k_bot), nz
      do i=0, nx-1
        if (z_bed(i) > z(k) .and. z(k) >= z_bed(i+1)) then
          tmp = (z_bed(i+1) - z(k))/(z_bed(i+1) - z_bed(i))
          len_hgt(k) = x(nx) - (tmp*x(i) + (1.-tmp)*x(i+1))
          exit
        endif
      enddo
    enddo

#ifdef V1D
    ! vertical 1d mode

    allocate ( &
      x1(0:1), z_bed1(0:1), b1(0:1,0:nz))

    allocate ( &
      xc1(1), dx1(1), dxs1(0), &
      au1(0:1,nz), aw1(1,0:nz), aus1(1,nz), aws1(0,0:nz), &
      vol1(1,nz), vols1(0,nz), &
      k_bot1(0:1), kc_bot1(1))

    allocate ( &
      au01(0:1,nz), aw01(1,0:nz), aus01(1,nz), aws01(0,0:nz), &
      vol01(1,nz), vols01(0,nz))

    ! x1, xc1, dx1, b1
    x1(0) = x(0); x1(1) = x(nx)
    z_bed1(0) = 0.; z_bed1(1) = 0.
    !b1(0,:) = b(0,:); b1(1,:) = b(nx,:)
    xc1(1) = (x1(0) + x1(1))/2
    dx1(1) = sum(dx(1:nx))

    ! au1, aw1, aus1, vol1, k_bot1, kc_bot1
    k_bot1(0) = 1; k_bot1(1) = 1
    kc_bot1(1) = 1

    allocate (east(0:nx,nz), i_inlet(nz))

    east(:,:) = .false.
    do i=1, nx-1
      do k=1, nz
        if (kc_bot(i) > k .and. k >= kc_bot(i+1)) east(i,k) = .true.
      enddo
    enddo
    do k=kc_bot(1), nz
      east(0,k) = .true.
    enddo
    i_inlet(:) = nx
    do i=0, nx-1
      do k=1, nz
        if (east(i,k)) i_inlet(k) = i
      enddo
    enddo

    ! b1(0:1,0:nz), au1(0:1,k), aw1(1,0:nz), vol1(1,nz)
    do k=1, nz
      b1(0,k) = b(i_inlet(k),k);  b1(1,k) = b(nx,k)
      au1(0,k) = au(i_inlet(k),k);  au1(1,k) = au(nx,k)
      !aw1(1,k) = sum(aw(i_inlet(k)+1:nx,k))
      aw1(1,k) = sum(aw(:,k))
      !vol1(1,k) = sum(vol(i_inlet(k)+1:nx,k))
      vol1(1,k) = sum(vol(:,k))
    enddo
    b1(0,0) = b(i_inlet(1),0);  b1(1,0) = b1(nx,0)
    !aw1(1,0) = sum(aw(i_inlet(1)+1:nx,0))
    aw1(1,0) = sum(aw(:,0))

    aus1(1,:) = (au1(0,:) + au1(1,:))/2

    deallocate (east, i_inlet)

    nullify ( &
      x, xc, dx, dxs, &
      b, au, aw, aus, aws, vol, vols, &
      au0, aw0, aus0, aws0, vol0, vols0, &
      k_bot, kc_bot)

    ! save the original geometry
    dz0 = dz;  dzs0 = dzs
    au01 = au1;  aw01 = aw1;  aus01 = aus1;  aws01 = aws1
    vol01 = vol1;  vols01 = vols1

    !--- pointer ----------------------------------------
    dom%nx=1; dom%nz=nz
    dom%x=>x1; dom%z=>z; dom%z_bed=>z_bed1; dom%b=>b1
    dom%xc=>xc1; dom%zc=>zc; dom%dx=>dx1; dom%dz=>dz; dom%dxs=>dxs1; dom%dzs=>dzs
    dom%au=>au1; dom%aw=>aw1; dom%aus=>aus1; dom%aws=>aws1
    dom%vol=>vol1; dom%vols=>vols1; dom%vol_hgt=>vol_hgt
    dom%area_hgt=>area_hgt; dom%len_hgt=>len_hgt; dom%vol_lay=>vol_lay
    dom%k_bot=>k_bot1; dom%kc_bot=>kc_bot1

    dom%dz0=>dz0; dom%dzs0=>dzs0
    dom%au0=>au01; dom%aw0=>aw01; dom%aus0=>aus01; dom%aws0=>aws01
    dom%vol0=>vol01; dom%vols0=>vols01
    !----------------------------------------------------

    return

#else
    ! streamwise-vertical 2d mode

    ! save the original geometry
    dz0 = dz;  dzs0 = dzs
    au0 = au;  aw0 = aw;  aus0 = aus;  aws0 = aws
    vol0 = vol;  vols0 = vols

    !--- pointer ----------------------------------------
    dom%nx=nx; dom%nz=nz
    dom%x=>x; dom%z=>z; dom%z_bed=>z_bed; dom%b=>b
    dom%xc=>xc; dom%zc=>zc; dom%dx=>dx; dom%dz=>dz; dom%dxs=>dxs; dom%dzs=>dzs
    dom%au=>au; dom%aw=>aw; dom%aus=>aus; dom%aws=>aws
    dom%vol=>vol; dom%vols=>vols; dom%vol_hgt=>vol_hgt
    dom%area_hgt=>area_hgt; dom%len_hgt=>len_hgt; dom%vol_lay=>vol_lay
    dom%k_bot=>k_bot; dom%kc_bot=>kc_bot

    dom%dz0=>dz0; dom%dzs0=>dzs0
    dom%au0=>au0; dom%aw0=>aw0; dom%aus0=>aus0; dom%aws0=>aws0
    dom%vol0=>vol0; dom%vols0=>vols0
    !----------------------------------------------------

    return

#endif


  end subroutine set_geometry


  subroutine allocate_variables(dom)

    use mod_parameter, only : nps
#ifdef WQ
    use mod_parameter, only : nwq
#endif
#ifdef TRACER
    use mod_parameter, only : ntr
#endif

    implicit none

    type(domain), intent(inout) :: dom

    integer :: nx, nz
  
    ! allocate variables
    nx=dom%nx; nz=dom%nz

    ! primary variables
    allocate ( &
      dom%u(0:nx,nz), dom%w(nx,0:nz), dom%t(0:nx+1,0:nz+1), &
      dom%s(0:nx+1,0:nz+1,nps))

    ! model variables
    allocate ( &
      dom%p(0:nx+1,0:nz+1), dom%rho(0:nx+1,0:nz+1), dom%rho_avg(0:nz) )
    dom%p=0.; dom%rho=0.; dom%rho_avg=0.
 
    allocate ( &
      dom%dmx(nx,nz), dom%dmz(nx,0:nz), &
      dom%dhx(nx,nz), dom%dhz(nx,0:nz), &
      dom%dcx(nx,nz), dom%dcz(nx,0:nz))

    allocate (dom%s_sed(0:nx+1,nps))
    dom%s_sed=0.0

#ifdef WQ
    ! water quality variables
    allocate ( &
      dom%wq(0:nx+1,0:nz+1,nwq), dom%wq_sed(0:nx+1,nwq))
      dom%wq_sed=0.0
#endif
#ifdef TRACER
    allocate (dom%tr(0:nx+1,0:nz+1,ntr))  ! tracer field
#endif

  end subroutine allocate_variables


  subroutine deallocate_variables(dom)

    implicit none

    type(domain), intent(inout) :: dom

    ! geometry variables
    nullify ( &
      dom%x, dom%z, dom%xc, dom%zc, dom%dx, dom%dz, dom%dxs, dom%dzs, dom%z_bed, &
      dom%b, dom%au, dom%aw, dom%aus, dom%aws, dom%vol, dom%vols, &
      dom%dz0, dom%dzs0, &
      dom%au0, dom%aw0, dom%aus0, dom%aws0, dom%vol0, dom%vols0, &
      dom%vol_hgt, dom%area_hgt, dom%len_hgt, &
      dom%k_bot, dom%kc_bot)
    
    ! primary variables
    nullify (dom%u, dom%w, dom%t, dom%s)

    ! model variables
    nullify ( &
      dom%p, dom%rho, dom%rho_avg, &
      dom%dmx, dom%dmz, dom%dhx, dom%dhz, dom%dcx, dom%dcz, &
      dom%s_sed)
#ifdef WQ
    nullify ( dom%wq, dom%wq_sed )
#endif
#ifdef TRACER
    nullify (dom%tr)
#endif

  end subroutine deallocate_variables


  subroutine update_surface_layer(dom)
    !
    ! input: z_srf
    ! output: k_srf, dz_srf, dz, dzs, au, aus, aw, aws, vol, vols
    !
    implicit none

    type(domain), intent(inout) :: dom

    integer :: nx, nz, k_srf
    real :: z_srf, dz_srf
    real, pointer :: z(:), zc(:), dx(:), dz(:), b(:,:)

    integer :: i, k
    real, allocatable, dimension(:) :: b_srf, au_srf, aus_srf, &
      aw_srf, aws_srf, vol_srf, vols_srf

    !--- pointer ----------------------------------------
    nx=dom%nx; nz=dom%nz; z_srf=dom%z_srf
    z=>dom%z; zc=>dom%zc; dx=>dom%dx; dz=>dom%dz; b=>dom%b
    !----------------------------------------------------

    allocate (b_srf(0:nx), au_srf(0:nx), aus_srf(nx), &
      aw_srf(nx), aws_srf(nx-1), vol_srf(nx), vols_srf(nx-1))

    ! k_srf, dz_srf
    if (z(nz) < z_srf) then
      print *, 'Error: z_srf exceeds the upper limit of the domain.'
      stop
    endif

    if (z_srf <= zc(1)) then
      print *, 'Error: z_srf exceeds the lower limit of the domain.'
      stop
    endif

    k_srf = 0
    do k=1, nz-1
      if (zc(k) <= z_srf .and. z_srf < zc(k+1)) k_srf = k
    enddo
    if (k_srf==0) k_srf = nz

    dz_srf = z_srf - z(k_srf-1)

    ! b_srf, au_srf
    do i=0, nx
      if (z_srf <= z(k_srf)) then
        b_srf(i) = b(i,k_srf-1) + &
          dz_srf/dz(k_srf) * (b(i,k_srf) - b(i,k_srf-1))
        au_srf(i) = (b(i,k_srf-1) + b_srf(i))/2 * dz_srf
      else
        b_srf(i) = b(i,k_srf) + &
          (z_srf - z(k_srf))/dz(k_srf+1) * (b(i,k_srf+1) - b(i,k_srf))
        au_srf(i) = (b(i,k_srf-1) + b(i,k_srf))/2 * dz(k_srf) + &
          (b(i,k_srf) + b_srf(i))/2 * (z_srf - z(k_srf))
      endif
    enddo

    do i=1, nx
      aus_srf(i) = (au_srf(i-1) + au_srf(i))/2
      aw_srf(i) = (b_srf(i-1) + b_srf(i))/2 * dx(i)
      vol_srf(i) = aus_srf(i) * dx(i)
    enddo

    do i=1, nx-1
      aws_srf(i) = (aw_srf(i) + aw_srf(i+1))/2
      vols_srf(i) = (vol_srf(i) + vol_srf(i+1))/2
    enddo

    ! set surface layer to geometry
    dom%dz = dom%dz0;  dom%dzs = dom%dzs0
    dom%au = dom%au0;  dom%aus = dom%aus0
    dom%aw = dom%aw0;  dom%aws = dom%aws0
    dom%vol = dom%vol0;  dom%vols = dom%vols0

    k = k_srf
    dom%k_srf = k_srf
    dom%dz_srf = dz_srf

    dom%dz(k) = dz_srf;  dom%dzs(k) = dz_srf
    dom%au(:,k) = au_srf(:);  dom%aus(:,k) = aus_srf(:)
    dom%aw(:,k) = aw_srf(:);  dom%aws(:,k) = aws_srf(:)
    dom%vol(:,k) = vol_srf(:);  dom%vols(:,k) = vols_srf(:)

    deallocate (b_srf, au_srf, aus_srf, aw_srf, vol_srf, vols_srf)

  end subroutine update_surface_layer


  subroutine get_total_volume(dom)
    !
    ! inputs:  z_srf, vol_hgt
    ! outputs: total_vol
    !
    implicit none

    type(domain), intent(inout) :: dom

    integer :: nz
    real :: z_srf, total_vol
    real, pointer :: z(:), vol_hgt(:)

    integer :: k

    !--- pointer ---
    nz=dom%nz; z=>dom%z
    z_srf=dom%z_srf; vol_hgt=>dom%vol_hgt
    !---------------

    total_vol = 0.0

    do k=1, nz
      if (z(k-1) <= z_srf .and. z_srf <= z(k)) then
        total_vol = vol_hgt(k-1) + &
          (vol_hgt(k) - vol_hgt(k-1))*(z_srf - z(k-1))/(z(k) - z(k-1))
      endif
    enddo

    if (total_vol > vol_hgt(nz)) then
      print *, 'Error: total_vol > vol_hgt(nz)'
      stop
    endif

    if (total_vol < 1.e-3) then
      print *, 'Error: total_vol=0'
      stop
    endif

    dom%total_vol = total_vol

  end subroutine get_total_volume


  subroutine get_surface_height(nz, z, vol_hgt, total_vol, z_srf)

    implicit none

    integer, intent(in) :: nz
    real, intent(in) :: z(0:nz), vol_hgt(0:nz), total_vol
    real, intent(out) :: z_srf

    integer :: k

    if (vol_hgt(nz) < total_vol) then
      print *, 'water volume has exceeded reservoir capacity' 
      stop
    endif

    z_srf = -999.

    do k=1, nz
      if (vol_hgt(k-1) < total_vol .and. total_vol <= vol_hgt(k)) then
        z_srf = z(k-1) + (z(k) - z(k-1))/(vol_hgt(k) - vol_hgt(k-1)) * &
          (total_vol - vol_hgt(k-1))
      endif
    enddo

    if (z_srf > z(nz)) then
      print *, 'Error: z_srf > z(nz)'
      stop
    endif

    if (z_srf < -900.) then
      print *, 'Error: z_srf is out of bounds'
      stop
    endif

  end subroutine get_surface_height


  subroutine set_initial(dom)
    !
    ! input  : fname_nml
    ! output : z_srf, u, w, t, s
    !
    use mod_parameter, only : nps, turbid_density
#ifdef WQ
    use mod_parameter, only : nwq
#endif
#ifdef TRACER
    use mod_parameter, only : ntr
#endif

    implicit none

    type(domain), intent(inout) :: dom

    integer :: i, j, k, io_stat, k_, n_
    real :: w_
    real, allocatable :: z_(:), u_(:), t_(:), s_(:,:)
#ifdef WQ
    real, allocatable :: wq_(:,:)
#endif
#ifdef TRACER
    real, allocatable :: tr_(:,:)
#endif

    real :: z_srf=40.      ! initial water surface level, m
    character(len=128) :: fname_init=''
    namelist /initial/ z_srf, fname_init

    ! loading from namelist file
    open(10, file=trim(dom%fname_nml), status='old')
    read(10, nml=initial)
    close(10)

    write(6, '(a)') trim(dom%name)
    write(6, nml=initial)

    ! set initial surface height, m
    dom%z_srf = z_srf

    ! read from a file

    ! count number of data
    open(10, file=trim(fname_init), status='old')
    i = 0
    do
      read(10, '(a)', iostat=io_stat)
      if (io_stat /= 0) exit
      i = i + 1
    enddo
    n_ = i - 1  ! skip header line
    close(10)

    ! allocate arrays
    allocate (z_(n_), u_(n_), t_(n_), s_(n_,nps))
#ifdef WQ
    allocate (wq_(n_,nwq))
#endif
#ifdef TRACER
    allocate (tr_(n_,ntr))
#endif

    ! read data
    open(10, file=trim(fname_init), status='old')
    read(10,*)  ! skip header line
    do i=1, n_
#ifndef WQ
#ifndef TRACER
      read(10,*) z_(i), u_(i), t_(i), (s_(i,j), j=1, nps)
#else
      read(10,*) z_(i), u_(i), t_(i), (s_(i,j), j=1, nps), &
        (tr_(i,j), j=1, ntr)
#endif
#else
#ifndef TRACER
      read(10,*) z_(i), u_(i), t_(i), (s_(i,j), j=1, nps), &
        (wq_(i,j), j=1, nwq)
#else
      read(10,*) z_(i), u_(i), t_(i), (s_(i,j), j=1, nps), &
        (wq_(i,j), j=1, nwq), (tr_(i,j), j=1, ntr)
#endif
#endif
    enddo
    close(10)

    do k=1, dom%nz

      do k_=1, n_-1
        if (z_(k_) <= dom%zc(k) .and. dom%zc(k) <= z_(k_+1)) then
          w_ = (z_(k_+1) - dom%zc(k))/(z_(k_+1) - z_(k_))
          dom%u(:,k) = w_*u_(k_) + (1.0-w_)*u_(k_+1)
          dom%t(:,k) = w_*t_(k_) + (1.0-w_)*t_(k_+1)
          do j=1, nps
            dom%s(:,k,j) = w_*s_(k_,j) + (1.0-w_)*s_(k_+1,j)
          enddo
#ifdef WQ
          do j=1, nwq
            dom%wq(:,k,j) = w_*wq_(k_,j) + (1.0-w_)*wq_(k_+1,j)
          enddo
#endif
#ifdef TRACER
          do j=1, ntr
            dom%tr(:,k,j) = w_*tr_(k_,j) + (1.0-w_)*tr_(k_+1,j)
          enddo
#endif
        endif
      enddo

      dom%t(:,0) = dom%t(:,1)
      dom%t(:,dom%nz+1) = dom%t(:,dom%nz)
      do j=1, nps
        dom%s(:,0,j) = dom%s(:,1,j)
        dom%s(:,dom%nz+1,j) = dom%s(:,dom%nz,j)
      enddo
#ifdef WQ
      do j=1, nwq
        dom%wq(:,0,j)=dom%wq(:,1,j)
        dom%wq(:,dom%nz+1,j) = dom%wq(:,dom%nz,j)
      enddo
#endif
#ifdef TRACER
      do j=1, ntr
        dom%tr(:,0,j) = dom%tr(:,1,j)
        dom%tr(:,dom%nz+1,j) = dom%tr(:,dom%nz,j)
      enddo
#endif
    enddo

    ! vertical velocity, w
    dom%w = 0.0

    deallocate (z_, u_, t_, s_)
#ifdef WQ
    deallocate (wq_)
#endif
#ifdef TRACER
    deallocate (tr_)
#endif

  end subroutine set_initial


  subroutine write_geo(dom)
    !
    ! input  : nx, nz, x, z, k_bot, kc_bot, i_inlet, z_bed, b, 
    !          vol_hgt, area_hgt, len_hgt
    ! output : 'out/d01/geo.dat'
    !
    implicit none

    type(domain), intent(in) :: dom

    open(10, file='out/' // trim(dom%name) // '/geo.dat' , status='unknown')

    write(10,'(2i5)') dom%nx, dom%nz
    write(10,'(1000e15.7)') dom%x
    write(10,'(1000e15.7)') dom%z
    write(10,'(1000i5)') dom%k_bot
    write(10,'(1000i5)') dom%kc_bot
    write(10,'(1000i5)') dom%i_inlet
    write(10,'(1000e15.7)') dom%z_bed
    write(10,'(1000000e15.7)') dom%b
    write(10,'(1000e15.7)') dom%vol_hgt
    write(10,'(1000e15.7)') dom%area_hgt
    write(10,'(1000e15.7)') dom%len_hgt

    close(10)

  end subroutine write_geo


  subroutine update_density(dom)
    !
    ! input  : t, c
    ! output : p, rho, rho_avg
    !
    use mod_parameter, only : gravity, turbid_density

    implicit none

    type(domain), intent(inout) :: dom

    integer :: nx, nz
    integer :: i, k, k_srf
    real, allocatable :: volay(:), rhoav(:)

    !--- pointer ---
    nx=dom%nx; nz=dom%nz
    !----------------

    if (dom%k_srf==0) then
      k_srf = dom%nz
    else
      k_srf = dom%k_srf
    endif

    do i=1, nx

      ! density, kg/m3
      do k=dom%kc_bot(i), k_srf
        dom%rho(i,k) = turbid_density(dom%t(i,k), sum(dom%s(i,k,:)))
      enddo

      ! ghost cell
      dom%rho(i,k_srf+1) = dom%rho(i,k_srf)

      ! hydrostatic pressure, Pa
      dom%p(i,k_srf) = dom%rho(i,k_srf) * gravity * (dom%z_srf - dom%zc(k_srf))
      do k=k_srf-1, dom%kc_bot(i), -1
        dom%p(i,k) = dom%p(i,k+1) &
          + (dom%rho(i,k) + dom%rho(i,k+1))/2 * gravity * dom%dzs(k)
      enddo

    enddo

    ! horizontaly averaged density

    ! rho level
    allocate (volay(nz), rhoav(nz))

    volay = 1e-6
    rhoav = 0.0

    do i=1, nx
      do k=dom%kc_bot(i), k_srf
        volay(k) = volay(k) + dom%vol(i,k)
        rhoav(k) = rhoav(k) + dom%vol(i,k)*dom%rho(i,k)
      enddo
    enddo

    do k=1, k_srf
      rhoav(k) = rhoav(k)/volay(k)
    enddo

    deallocate (volay)

    ! w level
    dom%rho_avg(0) = rhoav(1)
    dom%rho_avg(k_srf) = rhoav(k_srf)
    dom%rho_avg(min(k_srf+1,nz)) = rhoav(k_srf)

    do k=1, k_srf-1
      dom%rho_avg(k) = (rhoav(k) + rhoav(k+1))/2
    enddo

  end subroutine update_density


  subroutine set_turbulence(dom)

    implicit none

    type(domain), intent(inout) :: dom

    ! namelist
    real ::        &
      dmx0 = 5.0,  &  ! coeff of dmx, 1/day
      dmz0 = 1e-3, &  ! coeff of dmz, 1/day
      dhx0 = 5.0,  &  ! coeff of dhx, 1/day
      dhz0 = 1e-3, &  ! coeff of dhz, 1/day
      dcx0 = 5.0,  &  ! coeff of dcx, 1/day
      dcz0 = 1e-3, &  ! coeff of dcz, 1/day
      ll = 0.5,    &  ! strength param of the expornent
      mm = 0.5,    &  ! strength param of the expornent
      nn = 0.5,    &  ! strength param of the expornent
      dmix = 1e-3     ! vertical diffusivity of mixing zone, m2/s

    namelist /turbulence/ dmx0, dmz0, dhx0, dhz0, dcx0, dcz0, &
      ll, mm, nn, dmix

    ! loading from namelist file
    open(10, file=trim(dom%fname_nml), status='old')
    read(10, nml=turbulence)
    close(10)

    write(6, '(a)') trim(dom%name)
    write(6, nml=turbulence)

    dom%dmx0=dmx0; dom%dmz0=dmz0
    dom%dhx0=dhx0; dom%dhz0=dhz0
    dom%dcx0=dcx0; dom%dcz0=dcz0
    dom%ll=ll; dom%mm=mm; dom%nn=nn 
    dom%dmix=dmix

  end subroutine set_turbulence


  subroutine update_turbulence(dom)
    !
    ! input  : u, t, rho
    ! output : dmx, dmz, dhx, dhz
    !
    use mod_parameter, only : gravity, rho_water, c_water, &
      water_viscosity, water_density, water_thermal_conductivity

    implicit none

    type(domain), intent(inout) :: dom
    
    integer :: i, k, nx, nz
    real :: ri_, u1_, u2_, uz_, rhoz_, rho_, &
      t_, nu_, nut_, alpha_, alphat_, beta_, betat_

    nx=dom%nx; nz=dom%nz

    ! horizontal diffusivity
    do i=1, nx
      do k=1, nz

        ! temperature, deg-C
        t_ = dom%t(i,k)

        ! kinematic viscosity, m2/s
        nu_ = water_viscosity(t_)/water_density(t_)

        ! thermal diffusivity, m2/s
        alpha_ = water_thermal_conductivity(t_)/(rho_water*c_water*4186)

        ! concentration diffusivity, m2/s
        beta_ = nu_

        ! eddy viscosity, m2/s
        nut_ = (dom%dmx0/(3600*24))*dom%dx(i)**2

        ! eddy thermal diffusivity, m2/s
        alphat_ = (dom%dhx0/(3600*24))*dom%dx(i)**2

        ! eddy concentraion diffusivity, m2/s
        betat_ = nut_

        ! effective viscosity, m2/s
        dom%dmx(i,k) = nu_ + nut_

        ! effective thermal diffusivity, m2/s
        dom%dhx(i,k) = alpha_ + alphat_

        ! effective concentration diffusivity, m2/s
        dom%dcx(i,k) = beta_ + betat_

      enddo
    enddo

    ! vertical diffusivity
    dom%dmz(:,:) = 0.0
    dom%dhz(:,:) = 0.0
    dom%dcz(:,:) = 0.0

    do i=1, nx

      do k=dom%kc_bot(i), dom%k_srf-1

        ! temperature, deg-C
        t_ = (dom%t(i,k) + dom%t(i,k+1))/2

        ! kinematic viscosity, m2/s
        nu_ = water_viscosity(t_)/water_density(t_)

        ! thermal diffusivity, m2/s
        alpha_ = water_thermal_conductivity(t_)/(rho_water*c_water*4186)

        ! concentration diffusivity, m2/s
        beta_ = nu_

        ! local Richardson number
        u1_ = (dom%u(i-1,k) + dom%u(i,k))/2
        u2_ = (dom%u(i-1,k+1) + dom%u(i,k+1))/2
        uz_ = abs(u2_ - u1_)/dom%dzs(k) + 1.e-6
        rhoz_ = (dom%rho(i,k+1) - dom%rho(i,k))/dom%dzs(k)
        rho_ = (dom%rho(i,k) + dom%rho(i,k+1))/2
        ri_ = min(max(0.0, -gravity*rhoz_/(rho_*uz_**2)), 15.)

        ! eddy viscosity, m2/s
        nut_ = dom%dmz0*exp(-dom%ll*ri_)

        ! eddy thermal diffusivity, m2/s
        alphat_ = dom%dhz0*exp(-dom%mm*ri_)

        ! eddy concentration diffusivity, m2/s
        betat_ = dom%dcz0*exp(-dom%nn*ri_)

        ! effective diffusivity
        dom%dmz(i,k) = nu_ + nut_
        dom%dhz(i,k) = alpha_ + alphat_
        dom%dcz(i,k) = beta_ + betat_

        ! mixing for unstable zone
        if (dom%rho(i,k+1) > dom%rho(i,k)) then
          dom%dmz(i,k) = dom%dmix
          dom%dhz(i,k) = dom%dmix
          dom%dcz(i,k) = dom%dmix
        endif

      enddo

      dom%dmz(i,dom%kc_bot(i)-1) = dom%dmz(i,dom%kc_bot(i))
      dom%dhz(i,dom%kc_bot(i)-1) = dom%dhz(i,dom%kc_bot(i))
      dom%dcz(i,dom%kc_bot(i)-1) = dom%dcz(i,dom%kc_bot(i))

      dom%dmz(i,dom%k_srf) = dom%dmz(i,dom%k_srf-1)
      dom%dhz(i,dom%k_srf) = dom%dhz(i,dom%k_srf-1)
      dom%dcz(i,dom%k_srf) = dom%dhz(i,dom%k_srf-1)

    enddo

  end subroutine update_turbulence

end module mod_domain


module mod_boundary
  !
  ! module for boundary conditions
  !
  use mod_timeseries, only : timeseries, timeseries_read, timeseries_interp
  use mod_domain, only : domain, doms

  implicit none

contains

  subroutine set_boundary(dom)

    use mod_domain, only : get_total_volume, update_surface_layer
    use mod_parameter, only : nps, pi
#ifdef WQ
    use mod_parameter, only : nwq
#endif
#ifdef TRACER
    use mod_parameter, only : ntr
#endif

    implicit none

    type(domain), intent(inout) :: dom

    integer :: nx, nz, k_srf
    real, pointer, dimension(:) :: x, z, xc, zc, z_bed
    integer, pointer :: k_bot(:), kc_bot(:)

    integer :: i, j, k
    real :: tmp
    logical, allocatable :: east(:,:)  ! cell faces on the east side

    ! namelist
    integer :: id_up
    real :: fr_in, b_in, z_in_low
    character(len=128) :: fname_in

    integer :: n_out
    logical, dimension(10) :: surf_out
    real, dimension(10) :: z_out, fr_out, phi_out
    character(len=128) :: fname_out

    integer :: n_cnf
    integer :: id_cnf(10)
    real, dimension(10) :: x_cnf, theta_cnf

    integer :: n_wtp
    integer :: id_wtp(10)
    real, dimension(10) :: x_wtp, z_wtp, fr_wtp, phi_wtp, theta_wtp
    character(len=128) :: fname_wtp(10)

    integer :: n_pio
    logical :: trib_pio(10)
    real, dimension(10) :: x_pio, z_pio, fr_pio, phi_pio, theta_pio
    character(len=128) :: fname_pio(10)

    integer :: n_fnc
    logical :: type_fnc(10)
    real :: x_fnc(10), width_fnc(10)
    type(domain), pointer :: trb

    namelist /boundary/ &
      id_up, fr_in, b_in, z_in_low, fname_in, &
      n_out, surf_out, z_out, fr_out, phi_out, fname_out, &
      n_cnf, id_cnf, x_cnf, theta_cnf, &
      n_wtp, id_wtp, x_wtp, z_wtp, fr_wtp, phi_wtp, theta_wtp, fname_wtp, &
      n_pio, trib_pio, x_pio, z_pio, fr_pio, phi_pio, theta_pio, fname_pio, &
      n_fnc, type_fnc, x_fnc, width_fnc

    ! default parameters
    id_up=0; fr_in=0.25; b_in=100.; z_in_low=-999.; fname_in=''

    n_out=1; surf_out=.false.; z_out=-999.; fr_out=0.134; phi_out=90.
    fname_out=''

    n_cnf=0; id_cnf=0; x_cnf=-999.; theta_cnf=90.

    n_wtp=0; id_wtp=0; x_wtp=-999.; z_wtp=-999.; fr_wtp=0.134; phi_wtp=90.
    theta_wtp=90.; fname_wtp=''

    n_pio=0; trib_pio=.false.; x_pio=-999.; z_pio=-999.; fr_pio=0.134
    phi_pio=90.; theta_pio=90.; fname_pio=''

    n_fnc=0; type_fnc=.false.; x_fnc=-999.; width_fnc=10.

    ! read namelist parameters
    open(10, file=trim(dom%fname_nml), status='old')
    read(10, nml=boundary)
    close(10)

    ! write namelsit parameters
    write(6, '(a)') trim(dom%name)
    write(6, nml=boundary)

    !--- pointer ----------------------------------------
    nx=dom%nx;  nz=dom%nz
    x=>dom%x; z=>dom%z; xc=>dom%xc; zc=>dom%zc; z_bed=>dom%z_bed
    k_bot=>dom%k_bot; kc_bot=>dom%kc_bot; k_srf=dom%k_srf
    !----------------------------------------------------

    !-- inlet
    !
    allocate (dom%s_in(nps), dom%ts_in, dom%i_inlet(nz))
#ifdef WQ
    allocate (dom%wq_in(nwq))
#endif
#ifdef TRACER
    allocate (dom%tr_in(ntr))
#endif

    ! find inlet cell faces
    allocate (east(0:nx,nz))  ! east cell face (u-position)

    east(:,:) = .false.
    do i=1, nx-1
      do k=1, nz
        if (kc_bot(i) > k .and. k >= kc_bot(i+1)) east(i,k) = .true.
      enddo
    enddo

    do k=kc_bot(1), nz
      east(0,k) = .true.
    enddo

    dom%i_inlet(:) = nx

    do i=0, nx-1
      do k=1, nz
        if (east(i,k)) dom%i_inlet(k) = i
      enddo
    enddo

    deallocate (east)

    ! setup time series data
    if (id_up == 0) call timeseries_read(fname_in, dom%ts_in)

    ! parameter setting
    dom%id_up=id_up; dom%fr_in=fr_in; dom%b_in=b_in
    dom%z_in_low=z_in_low

    !-- outlet
    !
    allocate ( &
      dom%surf_outs(n_out), dom%z_outs(n_out), dom%fr_outs(n_out), dom%phi_outs(n_out), &
      dom%ts_out, dom%q_outs(n_out), dom%t_outs(n_out), dom%s_outs(n_out,nps), &
      dom%t_out, dom%s_out(nps))
#ifdef WQ
    allocate (dom%wq_outs(n_out,nwq), dom%wq_out(nwq))
#endif
#ifdef TRACER
    allocate (dom%tr_outs(n_out,ntr), dom%tr_out(ntr))
#endif

    ! setup time series data
    if (n_out > 0) call timeseries_read(fname_out, dom%ts_out)

    ! parameter setting
    dom%n_out=n_out; dom%surf_outs=surf_out(1:n_out)
    dom%z_outs=z_out(1:n_out); dom%fr_outs=fr_out(1:n_out)
    dom%phi_outs=phi_out(1:n_out)

    !-- confluence
    !
    allocate ( &
      dom%id_cnfs(n_cnf), &
      dom%q_cnfs(n_cnf), dom%t_cnfs(n_cnf), dom%s_cnfs(n_cnf,nps), &
      dom%theta_cnfs(n_cnf), dom%i_cnfs(n_cnf), &
      dom%q_cnf(nx,nz), dom%u_cnf(nx,nz), &
      dom%t_cnf(nx,nz), dom%s_cnf(nx,nz,nps))
#ifdef WQ
    allocate (dom%wq_cnfs(n_cnf,nwq), dom%wq_cnf(nx,nz,nwq))
#endif
#ifdef TRACER
    allocate (dom%tr_cnfs(n_cnf,ntr), dom%tr_cnf(nx,nz,ntr))
#endif

    ! check outflow conditions in tributary domains
    do j=1, n_cnf
      trb => doms(id_cnf(j))
      if (trb%n_out > 0) then
        trb%n_out = 0
        print '(a,a,a)', 'warning: overwrite n_out in domain ', &
          trim(trb%name), ' to 0.'
      endif
    enddo

    ! find confluence index, i
    do j=1, n_cnf
      do i=1, nx
        if (x(i-1) <= x_cnf(j) .and. x_cnf(j) < x(i)) then
          dom%i_cnfs(j) = i
          exit
        endif
      enddo
    enddo

    ! parameter setting
    dom%n_cnf=n_cnf
    dom%id_cnfs=id_cnf(1:n_cnf); dom%theta_cnfs=theta_cnf(1:n_cnf)

    !-- water pipe
    !
    allocate ( &
      dom%id_wtps(n_wtp), &
      dom%q_wtps(n_wtp), dom%t_wtps(n_wtp), dom%s_wtps(n_wtp,nps), &
      dom%fr_wtps(n_wtp), dom%phi_wtps(n_wtp), dom%theta_wtps(n_wtp), &
      dom%z_wtps(n_wtp), dom%i_wtps(n_wtp), dom%ts_wtps(n_wtp), &
      dom%q_wtp(nx,nz), dom%u_wtp(nx,nz), dom%t_wtp(nx,nz), dom%s_wtp(nx,nz,nps))
#ifdef WQ
    allocate (dom%wq_wtps(n_wtp,nwq), dom%wq_wtp(nx,nz,nwq))
#endif
#ifdef TRACER
    allocate (dom%tr_wtps(n_wtp,ntr), dom%tr_wtp(nx,nz,ntr))
#endif

    ! find water pipe index, i
    do j=1, n_wtp
      do i=1, nx
        if (x(i-1) <= x_wtp(j) .and. x_wtp(j) < x(i)) then
          dom%i_wtps(j) = i
          exit
        endif
      enddo
    enddo

    ! setup time series data
    if (n_wtp > 0) then
      do i=1, n_wtp
        if (trim(fname_wtp(i)) /= '') &
          call timeseries_read(fname_wtp(i), dom%ts_wtps(i))
      enddo
    endif

    ! parameter setting
    dom%n_wtp=n_wtp; dom%id_wtps=id_wtp(1:n_wtp)
    dom%fr_wtps=fr_wtp(1:n_wtp); dom%phi_wtps=phi_wtp(1:n_wtp)
    dom%theta_wtps=theta_wtp(1:n_wtp); dom%z_wtps=z_wtp(1:n_wtp)

    !-- point in-out
    !
    allocate ( &
      dom%trib_pios(n_pio), &
      dom%q_pios(n_pio), dom%t_pios(n_pio), dom%s_pios(n_pio,nps), &
      dom%fr_pios(n_pio), dom%phi_pios(n_pio), dom%theta_pios(n_pio), &
      dom%z_pios(n_pio), dom%i_pios(n_pio), dom%k_pios(n_pio), &
      dom%ts_pios(n_pio), &
      dom%q_pio(nx,nz), dom%u_pio(nx,nz), dom%t_pio(nx,nz), dom%s_pio(nx,nz,nps))
#ifdef WQ
    allocate (dom%wq_pios(n_pio,nwq), dom%wq_pio(nx,nz,nwq))
#endif
#ifdef TRACER
    allocate (dom%tr_pios(n_pio,ntr), dom%tr_pio(nx,nz,ntr))
#endif

    ! find point source index, i
    do j=1, n_pio
      do i=1, nx
        if (x(i-1) <= x_pio(j) .and. x_pio(j) < x(i)) then
          dom%i_pios(j) = i
          exit
        endif
      enddo
      if (.not. trib_pio(j)) then
        do k=1, nz
          if (z(k-1) <= z_pio(j) .and. z_pio(j) < z(k)) then
            dom%k_pios(j) = k
            exit
          endif
        enddo
      endif
    enddo

    ! setup time series data
    if (n_pio > 0) then
      do i=1, n_pio
        if (trim(fname_pio(i)) /= '') &
          call timeseries_read(fname_pio(i), dom%ts_pios(i))
      enddo
    endif

    ! parameter setting
    dom%n_pio=n_pio; dom%trib_pios(1:n_pio)=trib_pio(1:n_pio)
    dom%fr_pios=fr_pio(1:n_pio); dom%phi_pios=phi_pio(1:n_pio)*pi/180
    dom%theta_pios=theta_pio(1:n_pio); dom%z_pios=z_pio(1:n_pio)

    !-- fence
    !
#ifdef V1D
    n_fnc = 0
#endif

    allocate ( &
      dom%type_fncs(n_fnc), dom%width_fncs(n_fnc), &
      dom%i_fncs(n_fnc), dom%k_fncs(2,n_fnc))

    ! position indices of fences
    do j=1, n_fnc

      do i=1, nx-1
        if (xc(i) <= x_fnc(j) .and. x_fnc(j) < xc(i+1)) then
          dom%i_fncs(j) = i
          exit
        endif
      enddo

      if (type_fnc(j)) then ! floating type
      else                  ! fixed type
        dom%k_fncs(1,j) = k_bot(dom%i_fncs(j))
        tmp = z_bed(dom%i_fncs(j)) + width_fnc(j)
        do k=1, nz-1
          if (z(k) < tmp .and. tmp <= z(k+1)) then
            dom%k_fncs(2,j) = k
            exit
          endif
        enddo
      endif

    enddo

    ! parameter setting
    dom%n_fnc=n_fnc
    dom%type_fncs=type_fnc(1:n_fnc); dom%width_fncs=width_fnc(1:n_fnc)

    !-- column flowrate, m3/s
    !
    allocate (dom%q_col(nx))
    dom%q_col=0.0

    !-- surface layer
    !
    ! update total water volume by new z_srf
    call get_total_volume(dom)

    ! update surface layer by new z_srf
    call update_surface_layer(dom)

  end subroutine set_boundary


  subroutine update_inflow(dom, time_day)
    !
    ! inputs:  ts_in, time_day, rho_avg
    ! outputs: z_in, q_in, t_in, s_in, rho_in, u, t, s
    !
    use mod_parameter, only : gravity, nps, turbid_density, rho_water
#ifdef WQ
    use mod_parameter, only : nwq
#endif
#ifdef TRACER
    use mod_parameter, only : ntr
#endif

    implicit none

    type(domain), intent(inout) :: dom
    real, intent(in) :: time_day

    integer :: nz, k_srf
    real :: z_srf, rho_in, z_in
    integer, pointer :: kc_bot(:)
    real, pointer :: z(:), zc(:), dz(:), rho_(:)
    type(domain), pointer :: dom_up

    integer :: i, k, kc, kc_min
    real :: tmp, eps, delta, zeta
    real, allocatable :: array(:), f(:)

    !--- pointer and allocate arrays ---------------
    nz=dom%nz; k_srf=dom%k_srf; z_srf=dom%z_srf; kc_bot=>dom%kc_bot
    z=>dom%z; zc=>dom%zc; dz=>dom%dz; rho_=>dom%rho_avg
    allocate (f(dom%nz))
    !-----------------------------------------------

    if (dom%id_up > 0) then

      ! one-way coupling up- and down-stream domains.
      ! inflow of downstream domain to outflow of upstream domain
      dom_up => doms(dom%id_up)
      dom%q_in = sum(dom_up%q_outs)
      dom%t_in = dom_up%t_out
      dom%s_in = dom_up%s_out
#ifdef WQ
      dom%wq_in = dom_up%wq_out
#endif
#ifdef TRACER
      dom%tr_in = dom_up%tr_out
#endif

    else

      ! individual inflows to up- and down-stream domains.
      ! set inlet values at current time
      allocate (array(dom%ts_in%nv))
      call timeseries_interp(dom%ts_in, time_day, array)
      dom%q_in = array(1)  ! inlet flow, m3/s
      dom%t_in = array(2)  ! inlet temp., deg-C
      do i=1, nps
        dom%s_in(i) = array(2+i)  ! inlet SS, g/m3
      enddo
#ifdef WQ
      do i=1, nwq
        dom%wq_in(i) = array(2+nps+i)   ! inlet wq, g/m3
      enddo
#endif
#ifdef TRACER
      do i=1, ntr
#ifndef WQ
        dom%tr_in = array(2+nps+i)      ! inlet tracer, -
#else
        dom%tr_in = array(2+nps+nwq+i)  ! inlet tracer, -
#endif
      enddo
#endif
      deallocate (array)

    endif

    ! inlet density
    rho_in = turbid_density(dom%t_in, sum(dom%s_in))

    ! inlet height as equivalent density
    kc_min = minval(kc_bot)

    kc = -1
    z_in = -999.

    if (rho_in <= rho_(k_srf-1)) then
      z_in = z_srf
      kc = k_srf
    else if (rho_(kc_min) <= rho_in) then
      z_in = zc(kc_min)
      kc = kc_min
    else
      do k=k_srf-1, kc_min+1, -1
        if (rho_(k-1) >= rho_in .and. rho_in >= rho_(k)) then
          tmp = (rho_in - rho_(k))/(rho_(k-1) - rho_(k) + 1.e-8)
          z_in = tmp*z(k-1) + (1.0 - tmp)*z(k)
          kc = k
          exit
        endif
      enddo
    endif

    if (z_in < dom%z_in_low) then
      z_in = dom%z_in_low
      dom%z_in = z_in
      do k=kc_min, k_srf
        if (zc(k-1) <= z_in .and. z_in <= zc(k)) then
          kc = k
          exit
        endif
      enddo
    endif

    if (kc < 0) then
      print *, 'error: cant find kc, in subroutine update_inflow'
      stop
   endif

    ! normalized density gradient, 1/m
    eps = -(rho_(kc) - rho_(kc-1))/(z(kc) - z(kc-1))/rho_water
    eps = max(1.e-6, eps)

    ! flow depth of 2d jet, m
    delta = abs(dom%q_in) / (dom%fr_in*dom%b_in*sqrt(eps*gravity))
    delta = min(max(dz(kc), sqrt(delta)), z(nz)-z(0))

    ! velocity profile function
    f(:) = 0.0
    do k=1, k_srf
      zeta = (zc(k) - z_in)/delta
      if (-0.5 <= zeta .and. zeta <= 0.5) f(k) = exp(-0.5*(3.92*zeta)**2)
    enddo

    ! inlet velocity
    tmp = 1.e-8
    do k=1, k_srf
      i = dom%i_inlet(k)
      tmp = tmp + dom%au(i,k)*f(k)
    enddo
    do k=1, k_srf
      i = dom%i_inlet(k)
      dom%u(i,k) = dom%q_in*f(k)/tmp
    enddo

    ! inlet temerature and SS
    do k=1, k_srf
      i = dom%i_inlet(k)
      dom%t(i,k) = dom%t_in
      dom%s(i,k,:) = dom%s_in(:)
#ifdef WQ
      dom%wq(i,k,:) = dom%wq_in(:)
#endif
#ifdef TRACER
      dom%tr(i,k,:) = dom%tr_in(:)
#endif
    enddo

    ! total flowrate
    dom%qtot_in = dom%q_in

    !--- pointer and de-allocate arrays ---
    dom%z_in=z_in; dom%delta_in=delta; dom%rho_in=rho_in
    deallocate (f)
    !--------------------------------------

  end subroutine update_inflow


  subroutine update_outflow(dom, time_day)
    !
    ! inputs:  ts_out, time_day, rho_avg
    ! outputs: q_outs, u, t_out, s_out
    !
    use mod_parameter, only : pi, gravity, nps, rho_water
#ifdef WQ
    use mod_parameter, only : nwq
#endif
#ifdef TRACER
    use mod_parameter, only : ntr
#endif

    implicit none

    type(domain), intent(inout) :: dom
    real, intent(in) :: time_day

    integer :: nx, nz, k_srf
    real :: z_srf
    real, pointer :: z(:), zc(:), dz(:), rho_(:)

    integer :: i, j, k, l, kc, kb
    real :: tmp, eps, delta, zeta, q_, z_out
    real, allocatable :: array(:), f(:), u(:), q(:)

    !--- pointer and allocate arrays ---------------
    nx=dom%nx; nz=dom%nz; k_srf=dom%k_srf; z_srf=dom%z_srf
    z=>dom%z; zc=>dom%zc; dz=>dom%dz; rho_=>dom%rho_avg
    allocate (f(dom%nz), u(dom%nz), q(dom%nz))
    !-----------------------------------------------

    ! bottom k at outlet
    kb = dom%k_bot(nx)

    if (dom%n_out > 0) then  ! dam with some outlets

      ! get current outlet flowrate
      allocate (array(dom%ts_out%nv))
      call timeseries_interp(dom%ts_out, time_day, array)
      do i=1, dom%ts_out%nv
        dom%q_outs(i) = array(i)  ! outlet flow, m3/s
      enddo
      deallocate (array)

      ! outlet variables
      dom%u(nx,:)=0.0

      do j=1, dom%n_out

        kc = -1

        if (dom%surf_outs(j)) then ! surface outflow

          z_out = z_srf
          kc = k_srf

        else                     ! in-water outflow

          z_out = dom%z_outs(j)

          ! find kc
          if (dom%z_outs(j) >= z(k_srf-1)) then
            z_out = z_srf
            kc = k_srf
          else if (z(kb) >= dom%z_outs(j)) then
            z_out = z(kb)
            kc = kb
          else
            do k=k_srf-1, kb+1, -1
              if (z(k-1) <= dom%z_outs(j) .and. dom%z_outs(j) <= z(k)) then
                z_out = dom%z_outs(j)
                kc = k
                exit
              endif
            enddo
          endif

        endif

        if (kc < 0) then
          print *, 'error: cant find kc, in subroutine update_outflow'
          stop
       endif

        ! normalized density gradient, 1/m
        eps = -(rho_(kc) - rho_(kc-1))/(z(kc) - z(kc-1))/rho_water
        eps = max(1.e-8, eps)

        ! flow depth of axi-symmetric jet, m
        delta = abs(dom%q_outs(j)) / &
          (dom%fr_outs(j)*(dom%phi_outs(j)*pi/180)*sqrt(eps*gravity))
        delta = min(max(2*dz(kc), delta**0.333), z(nz)-z(0))

        ! velocity profile function
        f = 0.0
        do k=kb, k_srf
          zeta = (zc(k) - z_out)/delta
          if (-0.5 <= zeta .and. zeta <= 0.5) f(k) = exp(-0.5*(3.92*zeta)**2)
        enddo

        ! outlet velocity, temperature and suspended solids
        tmp = sum(dom%au(nx,kb:k_srf)*f(kb:k_srf))
        f(kb:k_srf) = f(kb:k_srf)/tmp
        u(kb:k_srf) = dom%q_outs(j)*f(kb:k_srf)
        q(kb:k_srf) = u(kb:k_srf)*dom%au(nx,kb:k_srf)
        dom%u(nx,kb:k_srf) = dom%u(nx,kb:k_srf) + u(kb:k_srf)
        q_ = dom%q_outs(j) + 1.e-8
        dom%t_outs(j) = sum(q(kb:k_srf)*dom%t(nx,kb:k_srf))/q_
        do i=1, nps
          dom%s_outs(j,i) = sum(q(kb:k_srf)*dom%s(nx,kb:k_srf,i))/q_
        enddo
#ifdef WQ
        do i=1, nwq
          dom%wq_outs(j,i) = sum(q(kb:k_srf)*dom%wq(nx,kb:k_srf,i))/q_
        enddo
#endif
#ifdef TRACER
        do i=1, ntr
          dom%tr_outs(j,i) = sum(q(kb:k_srf)*dom%tr(nx,kb:k_srf,i))/q_
        enddo
#endif

      enddo

    else if (dom%n_out == 0) then  ! open boundary

      dom%u(nx,kb:k_srf) = dom%u(nx-1,kb:k_srf)
      dom%t(nx+1,kb:k_srf) = dom%t(nx,kb:k_srf)
      do l=1, nps
        dom%s(nx+1,kb:k_srf,l) = dom%s(nx,kb:k_srf,l)
      enddo
#ifdef WQ
      do l=1, nps
        dom%wq(nx+1,kb:k_srf,l) = dom%wq(nx,kb:k_srf,l)
      enddo
#endif
#ifdef TRACER
      do l=1, ntr
        dom%tr(nx+1,kb:k_srf,l) = dom%tr(nx,kb:k_srf,l)
      enddo
#endif

    endif

    ! outlet temperature, suspended solids
    q = dom%au(nx,:)*dom%u(nx,:)
    tmp = sum(q(kb:k_srf)) + 1e-8
    dom%t_out = sum(q(kb:k_srf)*dom%t(nx,kb:k_srf))/tmp
    do i=1, nps
      dom%s_out(i) = sum(q(kb:k_srf)*dom%s(nx,kb:k_srf,i))/tmp
    enddo
#ifdef WQ
    do i=1, nwq
      dom%wq_out(i) = sum(q(kb:k_srf)*dom%wq(nx,kb:k_srf,i))/tmp
    enddo
#endif
#ifdef TRACER
    do i=1, ntr
      dom%tr_out(i) = sum(q(kb:k_srf)*dom%tr(nx,kb:k_srf,i))/tmp
    enddo
#endif

    ! total flowrate
    if (dom%n_out == 0) then
      kb = dom%kc_bot(nx)
      dom%qtot_out = sum(dom%au(nx-1,kb:k_srf)*dom%u(nx-1,kb:k_srf))
    else
      dom%qtot_out = sum(dom%q_outs)
    endif

    !--- de-allocate arrays ---
    deallocate (f, u, q)
    !--------------------------

  end subroutine update_outflow


  subroutine update_confluence(dom)
    !
    ! inputs:  dom%id_cnfs, time_day
    ! outputs: q_cnf, u_cnf, t_cnf, s_cnf, q_cnfs, t_cnfs, s_cnfs
    !
    use mod_parameter, only : pi, nps
#ifdef WQ
    use mod_parameter, only : nwq
#endif
#ifdef TRACER
    use mod_parameter, only : ntr
#endif

    implicit none

    type(domain), intent(inout) :: dom

    integer :: i, j, l, kb, k_srf, nx
    real :: cos_, qtot_
    real, allocatable :: q(:)
    type(domain), pointer :: trb

    !--- pointer and allocate arrays ---------------
    allocate (q(dom%nz))
    !-----------------------------------------------

    ! confluence source term for momentum-eq, heat-eq and SS-eq
    dom%q_cnf=0.;  dom%u_cnf=0.;  dom%t_cnf=0.;  dom%s_cnf=0.
#ifdef WQ
    dom%wq_cnf=0.
#endif
#ifdef TRACER
    dom%tr_cnf=0.
#endif

    do j=1, dom%n_cnf

      ! upstream tributary domain
      trb => doms(dom%id_cnfs(j))

      ! confluence position index
      i = dom%i_cnfs(j)

      ! check mesh consistency
      if (dom%nz /= trb%nz .or. dom%kc_bot(i) /= trb%kc_bot(trb%nx)) then
        print *, 'error: the confluent domains mesh is not consistent.'
        print *, 'dom%nz, trb%nz = ', dom%nz, trb%nz
        print *, 'i, dom%kc_bot(i), trb%kc_bot(trb%nx) = ', &
          i, dom%kc_bot(i), trb%kc_bot(trb%nx)
        stop
      endif

      ! confluecne angle
      cos_ = cos(dom%theta_cnfs(j)*pi/180)

      nx = trb%nx
      kb = dom%kc_bot(i)
      k_srf = dom%k_srf

      q(kb:k_srf) = trb%u(nx-1,kb:k_srf)*trb%au(nx-1,kb:k_srf)
      qtot_ = sum(q(kb:k_srf)) + 1e-8

      dom%q_cnf(i,kb:k_srf) = q(kb:k_srf) !*(trb%q_col(dom%nx)/qtot_)
      dom%u_cnf(i,kb:k_srf) = cos_*(q(kb:k_srf)/(dom%dz(kb:k_srf)*dom%dx(i)))
      dom%t_cnf(i,kb:k_srf) = trb%t(nx,kb:k_srf)
      do l=1, nps
        dom%s_cnf(i,kb:k_srf,l) = trb%s(nx,kb:k_srf,l)
      enddo
#ifdef WQ
      do l=1, nwq
        dom%wq_cnf(i,kb:k_srf,l) = trb%wq(nx,kb:k_srf,l)
      enddo
#endif
#ifdef TRACER
      do l=1, ntr
        dom%tr_cnf(i,kb:k_srf,l) = trb%tr(nx,kb:k_srf,l)
      enddo
#endif

      dom%q_cnfs(j) = qtot_
      dom%t_cnfs(j) = sum(q(kb:k_srf)*dom%t_cnf(i,kb:k_srf))/qtot_
      do l=1, nps
        dom%s_cnfs(j,l) = sum(q(kb:k_srf)*dom%s_cnf(i,kb:k_srf,l))/qtot_
      enddo
#ifdef WQ
      do l=1, nwq
        dom%wq_cnfs(j,l) = sum(q(kb:k_srf)*dom%wq_cnf(i,kb:k_srf,l))/qtot_
      enddo
#endif
#ifdef TRACER
      do l=1, ntr
        dom%tr_cnfs(j,l) = sum(q(kb:k_srf)*dom%tr_cnf(i,kb:k_srf,l))/qtot_
      enddo
#endif
    enddo

    ! outflow boundary conditions of tributary domain
    do j=1, dom%n_cnf
      trb => doms(dom%id_cnfs(j))
      kb = trb%k_bot(trb%nx)
      k_srf = trb%k_srf

      trb%t(trb%nx+1,kb:k_srf) = dom%t(dom%nx,kb:k_srf)
      trb%s(trb%nx+1,kb:k_srf,:) = dom%s(dom%nx,kb:k_srf,:)
#ifdef WQ
      trb%wq(trb%nx+1,kb:k_srf,:) = dom%wq(dom%nx,kb:k_srf,:)
#endif
#ifdef TRACER
      trb%tr(trb%nx+1,kb:k_srf,:) = dom%tr(dom%nx,kb:k_srf,:)
#endif
    enddo

    ! total flowrate
    dom%qtot_cnf = sum(dom%q_cnfs)

    !--- de-allocate arrays ---
    deallocate (q)
    !--------------------------

  end subroutine update_confluence


  subroutine update_waterpipe(dom, time_day)
    !
    ! inputs:  ts_wtps, time_day, rho_avg
    ! outputs: q_wtp, u_wtp, t_wtp, s_wtp
    !
    use mod_parameter, only : pi, gravity, nps, rho_water
#ifdef WQ
    use mod_parameter, only : nwq
#endif
#ifdef TRACER
    use mod_parameter, only : ntr
#endif

    implicit none

    type(domain), intent(inout) :: dom
    real, intent(in) :: time_day

    integer :: nz, k_srf
    real :: z_srf
    real, pointer :: z(:), zc(:), dz(:), rho_(:)
    type(domain), pointer :: wtp

    integer :: i, j, k, l, kc, kb
    real :: tmp, eps, zeta, delta, cos_
    real, allocatable :: array(:), f(:,:), q(:)

    !--- pointer and allocate arrays ---------------
    nz=dom%nz; k_srf=dom%k_srf; z_srf=dom%z_srf
    z=>dom%z; zc=>dom%zc; dz=>dom%dz; rho_=>dom%rho_avg
    allocate (f(dom%n_wtp,dom%nz), q(dom%nz))
    !-----------------------------------------------

    do j=1, dom%n_wtp

      if (dom%id < dom%id_wtps(j)) then

        ! get current flowrate
        allocate (array(dom%ts_wtps(j)%nv))
        call timeseries_interp(dom%ts_wtps(j), time_day, array)
        dom%q_wtps(j) = array(1)  ! water pipe flow, m3/s
        deallocate (array)

      else

        ! set flowrate as negative of upstreams value
        wtp => doms(dom%id_wtps(j))  ! water pipe connection domain
        dom%q_wtps(j) = -wtp%q_wtps(j)

      endif

    enddo

    ! water pipe source term for momentum-eq, heat-eq and SS-eq
    dom%q_wtp=0.;  dom%u_wtp=0.;  dom%t_wtp=0.;  dom%s_wtp=0.
#ifdef WQ
    dom%wq_wtp=0.
#endif
#ifdef TRACER
    dom%tr_wtp=0.
#endif

    do j=1, dom%n_wtp

      i = dom%i_wtps(j)    ! position index of water pipe
      kb = dom%kc_bot(i)   ! bottom k of water pipe

      ! find kc
      kc = -1

      if (dom%z_wtps(j) >= z(k_srf-1)) then
        kc = k_srf
      else if (z(kb) >= dom%z_wtps(j)) then
        kc = 1
      else
        do k=k_srf-1, kb+1, -1
          if (z(k-1) <= dom%z_wtps(j) .and. dom%z_wtps(j) <= z(k)) then
            kc = k
            exit
          endif
        enddo
      endif

      if (kc < 0) then
        print *, 'error: cant find kc, in subroutine update_waterpipe'
        stop
      endif

      ! normalized density gradient, 1/m
      eps = -(rho_(kc) - rho_(kc-1))/(z(kc) - z(kc-1))/rho_water
      eps = max(1.e-6, eps)

      ! flow depth of axi-symmetric jet, m
      delta = abs(dom%q_wtps(j)) / &
        (dom%fr_wtps(j)*(dom%phi_wtps(j)*pi/180)*sqrt(eps*gravity))
      delta = min(max(2*dz(kc), delta**0.333), z(nz)-z(0))

      ! velocity profile function
      f(j,:) = 0.0
      do k=kb, k_srf
        zeta = (zc(k) - dom%z_wtps(j))/delta
        if (-0.5 <= zeta .and. zeta <= 0.5) f(j,k) = exp(-0.5*(3.92*zeta)**2)
      enddo

      wtp => doms(dom%id_wtps(j))           ! water pipe connection domain
      cos_ = cos(dom%theta_wtps(j)*pi/180)  ! water pipe angle

      f(j,kb:k_srf) = f(j,kb:k_srf)/sum(f(j,kb:k_srf))
      q(kb:k_srf) = dom%q_wtps(j)*f(j,kb:k_srf)

      ! source term
      dom%q_wtp(i,kb:k_srf) = q(kb:k_srf)
      dom%u_wtp(i,kb:k_srf) = cos_*(dom%q_wtps(j)/dom%aus(i,kb:k_srf))
      dom%t_wtp(i,kb:k_srf) = wtp%t_wtps(j)
      do l=1, nps
        dom%s_wtp(i,kb:k_srf,l) = wtp%s_wtps(j,l)
      enddo
#ifdef WQ
      do l=1, nwq
        dom%wq_wtp(i,kb:k_srf,l) = wtp%wq_wtps(j,l)
      enddo
#endif
#ifdef TRACER
      do l=1, ntr
        dom%tr_wtp(i,kb:k_srf,l) = wtp%tr_wtps(j,l)
      enddo
#endif
    enddo

    ! water pipe temperature and suspended solids
    do j=1, dom%n_wtp
      i = dom%i_wtps(j)
      kb = dom%kc_bot(i)

      f(j,kb:k_srf) = f(j,kb:k_srf)*dom%vol(i,kb:k_srf)
      tmp = sum(f(j,kb:k_srf))

      dom%t_wtps(j) = sum(f(j,kb:k_srf)*dom%t(i,kb:k_srf))/tmp
      do l=1, nps
        dom%s_wtps(j,l) = sum(f(j,kb:k_srf)*dom%s(i,kb:k_srf,l))/tmp
      enddo
#ifdef WQ
      do l=1, nwq
        dom%wq_wtps(j,l) = sum(f(j,kb:k_srf)*dom%wq(i,kb:k_srf,l))/tmp
      enddo
#endif
#ifdef TRACER
      do l=1, ntr
        dom%tr_wtps(j,l) = sum(f(j,kb:k_srf)*dom%tr(i,kb:k_srf,l))/tmp
      enddo
#endif
    enddo

    ! total flowrate
    dom%qtot_wtp = sum(dom%q_wtps)

    !--- de-allocate arrays ---
    deallocate (f, q)
    !--------------------------

  end subroutine update_waterpipe


  subroutine update_pointio(dom, time_day)
    !
    ! inputs:  ts_pios, time_day, rho_avg
    ! outputs: q_pio, u_pio, t_pio, s_pio
    !
    use mod_parameter, only : pi, gravity, nps, rho_water, turbid_density
#ifdef WQ
    use mod_parameter, only : nwq
#endif
#ifdef TRACER
    use mod_parameter, only : ntr
#endif

    implicit none

    type(domain), intent(inout) :: dom
    real, intent(in) :: time_day

    integer :: nz, k_srf
    real :: z_srf
    real, pointer :: dx(:), z(:), zc(:), dz(:), rho_(:)

    integer :: i, j, k, l, i_beg, kc, kb
    real :: tmp, rho_trb, z_trb, eps, zeta, delta, cos_, q_
    real, allocatable :: array(:), f(:)

    !--- pointer and allocate arrays ---------------
    nz=dom%nz; k_srf=dom%k_srf; z_srf=dom%z_srf
    dx=>dom%dx; z=>dom%z; zc=>dom%zc; dz=>dom%dz; rho_=>dom%rho_avg
    allocate (f(dom%nz))
    !-----------------------------------------------

    do j=1, dom%n_pio

      ! get current flow variables
      allocate (array(dom%ts_pios(j)%nv))
      call timeseries_interp(dom%ts_pios(j), time_day, array)
      dom%q_pios(j) = array(1)  ! flow rate, m3/s
      dom%t_pios(j) = array(2)  ! temperature, deg-C (ignored if negative q)
      do i=1, nps
        dom%s_pios(j,i) = array(2+i)  ! SS, g/m3 (ignored if negative q)
      enddo
      i_beg = 2 + nps
#ifdef WQ
      do i=1, nwq
        dom%wq_pios(j,i) = array(i_beg+i)  ! wq, g/m3 (ignored if negative q)
      enddo
      i_beg = i_beg + nwq
#endif
#ifdef TRACER
      do i=1, ntr
        dom%tr_pios(j,i) = array(i_beg+i)  ! tracer, - (ignored if negative q)
      enddo
#endif
      deallocate (array)

    enddo

    ! source term of point in-out for momentum-eq, heat-eq and SS-eq
    dom%q_pio=0.;  dom%u_pio=0.;  dom%t_pio=0.;  dom%s_pio=0.
#ifdef WQ
    dom%wq_pio=0.
#endif
#ifdef TRACER
    dom%tr_pio=0.
#endif

    do j=1, dom%n_pio

      i = dom%i_pios(j)   ! position index i of point in-out
      kb = dom%kc_bot(i)  ! bottom k of point in-out

      ! find kc
      if (dom%trib_pios(j)) then ! tributary mode

        ! tributary flow density
        rho_trb = turbid_density(dom%t_pios(j), sum(dom%s_pios(j,:)))

        ! tributary height as equivalent density
        kc = -1

        if (rho_trb <= rho_(k_srf-1)) then
          z_trb = z_srf
          kc = k_srf
        else if (rho_(kb) <= rho_trb) then
          z_trb = zc(kb)
          kc = kb
        else
          do k=k_srf-1, kb+1, -1
            if (rho_(k-1) >= rho_trb .and. rho_trb >= rho_(k)) then
              tmp = (rho_trb - rho_(k))/(rho_(k-1) - rho_(k) + 1.e-8)
              z_trb = tmp*z(k-1) + (1.0 - tmp)*z(k)
              kc = k
              exit
            endif
          enddo
        endif

        if (kc < 0) then
          print *, 'error: cant find kc, in subroutine update_pointio'
          stop
        endif

        dom%z_pios(j) = z_trb

      else

        kc = dom%k_pios(j)

      endif

      ! normalized density gradient, 1/m
      eps = -(rho_(kc) - rho_(kc-1))/(z(kc) - z(kc-1))/rho_water
      eps = max(1.e-6, eps)

      ! flow depth, m
      delta = abs(dom%q_pios(j)) / &
        (dom%fr_pios(j)*dom%phi_pios(j)*sqrt(eps*gravity))
      if (dom%trib_pios(j)) then  ! 2d jet
        delta = sqrt(delta)
      else                        ! axi-symmetric jet
        delta = delta**0.333
      endif
      delta = min(max(2*dz(kc), delta), z(nz)-z(0))

      ! velocity profile function
      f = 0.0
      do k=kb, k_srf
        zeta = (zc(k) - dom%z_pios(j))/delta
        if (-0.5 <= zeta .and. zeta <= 0.5) f(k) = exp(-0.5*(3.92*zeta)**2)
      enddo
      f(kb:k_srf) = f(kb:k_srf)/sum(f(kb:k_srf))

      ! flow angle of point inflow
      cos_ = cos(dom%theta_pios(j)*pi/180)

      ! source term of point in-out
      do k=kb, k_srf
        q_ = dom%q_pios(j)*f(k)
        dom%q_pio(i,k) = dom%q_pio(i,k) + q_
        if (dom%trib_pios(j)) then  ! tributary mode
          dom%u_pio(i,k) = dom%u_pio(i,k) + cos_*(q_/(dz(k)*dx(i)))
        else
          dom%u_pio(i,k) = dom%u_pio(i,k) + cos_*(q_/dom%aus(i,k))
        endif
        if (dom%q_pios(j) > 0.) then  ! inflow condition
          dom%t_pio(i,k) = dom%t_pios(j)
          do l=1, nps
            dom%s_pio(i,k,l) = dom%s_pios(j,l)
          enddo
#ifdef WQ
          do l=1, nwq
            dom%wq_pio(i,k,l) = dom%wq_pios(j,l)
          enddo
#endif
#ifdef TRACER
          do l=1, ntr
            dom%tr_pio(i,k,l) = dom%tr_pios(j,l)
          enddo
#endif
        endif
      enddo

      ! point outflow temperature and suspended solids
      if (dom%q_pios(j) < 0.) then
        f(kb:k_srf) = f(kb:k_srf)*dom%vol(i,kb:k_srf)
        f(kb:k_srf) = f(kb:k_srf)/sum(f(kb:k_srf))
        dom%t_pios(j) = sum(f(kb:k_srf)*dom%t(i,kb:k_srf))
        do l=1, nps
          dom%s_pios(j,l) = sum(f(kb:k_srf)*dom%s(i,kb:k_srf,l))
        enddo
#ifdef WQ
        do l=1, nwq
          dom%wq_pios(j,l) = sum(f(kb:k_srf)*dom%wq(i,kb:k_srf,l))
        enddo
#endif
#ifdef TRACER
        do l=1, ntr
          dom%tr_pios(j,l) = sum(f(kb:k_srf)*dom%tr(i,kb:k_srf,l))
        enddo
#endif
      endif

    enddo ! end of loop j

    ! total flowrate
    dom%qtot_pio = sum(dom%q_pios)

    !--- de-allocate arrays ---
    deallocate (f)
    !--------------------------

  end subroutine update_pointio


  subroutine update_column_flowrate(dom)
    !
    ! inputs:  u, w_srf, q_cnfs, q_wtps, q_pios
    ! outputs: q_col
    !
    implicit none

    type(domain), intent(inout) :: dom

    integer :: nx, k_srf
    real, pointer :: q_col(:)

    integer :: i, j, k, ii
    real :: tmp, tmp1

    !--- pointer  ---------------
    nx=dom%nx; k_srf=dom%k_srf; q_col=>dom%q_col
    !----------------------------

    ! zero clear
    q_col(:) = 0.0

    ! inlet
    do i=1, nx
      do k=1, k_srf
        ii = dom%i_inlet(k)
        if (ii < i) q_col(i) = q_col(i) + dom%au(ii,k)*dom%u(ii,k)
      enddo
    enddo

    ! surface
    tmp1 = 1.e-20
    do i=1, nx
      tmp1 = tmp1 + dom%w_srf*dom%aw(i,k_srf)
    enddo
    tmp1 = dom%q_total_vol/tmp1

    tmp = 0.0
    do i=1, nx
      tmp = tmp + dom%w_srf*dom%aw(i,k_srf)*tmp1
      q_col(i) = q_col(i) - tmp
    enddo

    ! confluence
    do j=1, dom%n_cnf
      do i=dom%i_cnfs(j), nx
        q_col(i) = q_col(i) + dom%q_cnfs(j)
      enddo
    enddo

    ! water pipe
    do j=1, dom%n_wtp
      do i=dom%i_wtps(j), nx
        q_col(i) = q_col(i) + dom%q_wtps(j)
      enddo
    enddo

    ! point in-out
    do j=1, dom%n_pio
      do i=dom%i_pios(j), nx
        q_col(i) = q_col(i) + dom%q_pios(j)
      enddo
    enddo

    ! because of numerical errors in the flowrate due to surface variation
    if (dom%n_out > 0) q_col(nx) = sum(dom%q_outs)

  end subroutine update_column_flowrate


  subroutine update_floating_fence(dom)
    !
    ! inputs:  z_srf, width_fncs
    ! outputs: k_fnc
    !
    implicit none

    type(domain), intent(inout) :: dom

    integer :: k_srf
    integer, pointer :: k_bot(:)
    real, pointer :: zc(:)

    integer :: i, j, k
    real :: z_fbot

    !--- pointer  ---------------------------------
    k_srf=dom%k_srf; k_bot=>dom%k_bot; zc=>dom%zc
    !----------------------------------------------

    do j=1, dom%n_fnc

      if (dom%type_fncs(j)) then

        ! bottom height of floating fence
        z_fbot = dom%z_srf - dom%width_fncs(j)

        ! lower bound of k_fnc
        i = dom%i_fncs(j)
        do k=k_bot(i), k_srf
          if (zc(k) <= z_fbot .and. z_fbot < zc(k+1)) then
            dom%k_fncs(1,j) = k
            exit
          endif
        enddo

        ! upper bound of k_fnc
        dom%k_fncs(2,j) = k_srf

      endif

    enddo

  end subroutine update_floating_fence


  subroutine update_boundary(dom, time_day)

    use mod_parameter, only : turbid_density

    implicit none

    type(domain), intent(inout) :: dom
    real, intent(in) :: time_day

    !-- update inflow
    call update_inflow(dom, time_day)

    !-- update outflow
    call update_outflow(dom, time_day)

    !-- update confluence
    dom%q_cnf=0.;  dom%u_cnf=0.;  dom%t_cnf=0.;  dom%s_cnf=0.
#ifdef WQ
    dom%wq_cnf=0.
#endif
#ifdef TRACER
    dom%tr_cnf=0.
#endif
    if (dom%n_cnf > 0) call update_confluence(dom)

    !-- update water pipe
    dom%q_wtp=0.;  dom%u_wtp=0.;  dom%t_wtp=0.;  dom%s_wtp=0.
#ifdef WQ
    dom%wq_wtp=0.
#endif
#ifdef TRACER
    dom%tr_wtp=0.
#endif
    if (dom%n_wtp > 0) call update_waterpipe(dom, time_day)

    !-- update point in-out
    dom%q_pio=0.;  dom%u_pio=0.;  dom%t_pio=0.;  dom%s_pio=0.
#ifdef WQ
    dom%wq_pio=0.
#endif
#ifdef TRACER
    dom%tr_pio=0.
#endif
    if (dom%n_pio > 0) call update_pointio(dom, time_day)

  end subroutine update_boundary


  subroutine update_surface(ndom, dt_sec)

    use mod_domain, only : update_surface_layer, get_surface_height
    implicit none

    integer, intent(in) :: ndom
    real, intent(in) :: dt_sec

    integer :: i, j
    real :: z_srf, z_srf_old, total_vol
    real, allocatable :: vol_hgt(:)
    type(domain), pointer :: dom

    do i=1, ndom
      dom => doms(i)

      !-- update total volume
      dom%q_total_vol = &
        dom%qtot_in + dom%qtot_wtp + &
        dom%qtot_cnf + dom%qtot_pio - dom%qtot_out

      dom%total_vol = dom%total_vol + dt_sec*dom%q_total_vol

      !-- update column flow rate (q_col)
      call update_column_flowrate(dom)

    enddo

    do i=1, ndom
      dom => doms(i)

      z_srf_old = dom%z_srf

      ! estimate water surface elevation, z_srf
      if (dom%n_out==0) then  ! no z_srf estimation
      else if (dom%n_cnf > 0) then  ! z_srf shared by all confluent domains

        allocate (vol_hgt(0:dom%nz))

        total_vol = dom%total_vol
        vol_hgt = dom%vol_hgt

        do j=1, dom%n_cnf
          total_vol = total_vol + doms(dom%id_cnfs(j))%total_vol
          vol_hgt = vol_hgt + doms(dom%id_cnfs(j))%vol_hgt
        enddo

        call get_surface_height(dom%nz, dom%z, vol_hgt, total_vol, z_srf)

        dom%z_srf = z_srf
        dom%w_srf = (z_srf - z_srf_old)/dt_sec

        do j=1, dom%n_cnf
          doms(dom%id_cnfs(j))%z_srf = z_srf
          doms(dom%id_cnfs(j))%w_srf = (z_srf - z_srf_old)/dt_sec 
        enddo

        deallocate (vol_hgt)

      else  ! z_srf of single domain

        call get_surface_height(dom%nz, dom%z, dom%vol_hgt, &
          dom%total_vol, dom%z_srf)

        dom%w_srf = (dom%z_srf - z_srf_old)/dt_sec

      endif

    enddo

    do i=1, ndom
      dom => doms(i)

      ! update surface geometry by new z_srf
      call update_surface_layer(dom)

      !-- update floating fence
      if (dom%n_fnc > 0) call update_floating_fence(dom)

    enddo

  end subroutine update_surface


  subroutine deallocate_boundary(dom)

    use mod_domain, only : domain

    implicit none

    type(domain), intent(inout) :: dom

    nullify (dom%s_in, dom%ts_in, dom%i_inlet)

    nullify ( &
      dom%surf_outs, dom%z_outs, dom%fr_outs, dom%phi_outs, &
      dom%ts_out, dom%q_outs, dom%t_outs, dom%s_outs, &
      dom%t_out, dom%s_out)

    nullify ( &
      dom%q_cnfs, & !dom%t_cnfs, dom%s_cnfs, &
      dom%theta_cnfs, dom%i_cnfs, &
      dom%q_cnf, dom%u_cnf, dom%t_cnf, dom%s_cnf)

    nullify ( &
      dom%id_wtps, dom%q_wtps, dom%t_wtps, dom%s_wtps, &
      dom%fr_wtps, dom%phi_wtps, dom%theta_wtps, &
      dom%i_wtps, dom%ts_wtps, &
      dom%q_wtp, dom%u_wtp, dom%t_wtp, dom%s_wtp)

    nullify ( &
      dom%q_pios, dom%t_pios, dom%s_pios, &
      dom%fr_pios, dom%phi_pios, dom%theta_pios, &
      dom%i_pios, dom%k_pios, dom%ts_pios, &
      dom%q_pio, dom%u_pio, dom%t_pio, dom%s_pio)

#ifdef WQ
    nullify ( &
      dom%wq_in, dom%wq_outs, dom%wq_out, dom%wq_cnfs, dom%wq_cnf, &
      dom%wq_wtps, dom%wq_wtp, dom%wq_pios, dom%wq_pio)

    nullify ( dom%wq, dom%wq_sed )
#endif
#ifdef TRACER
    nullify ( &
      dom%tr_in, dom%tr_outs, dom%tr_out, &
      dom%tr_cnfs, dom%tr_cnf, dom%tr_wtps, dom%tr_wtp, &
      dom%tr_pios, dom%tr_pio)
#endif

  end subroutine deallocate_boundary

end module mod_boundary


module mod_utility
  !
  ! module for utility tools
  !
  use mod_domain, only : domain

  implicit none

contains

  logical function divisible_by(time, dt)

    implicit none
    real, intent(in) :: time, dt
    real :: time_
    real, parameter :: eps=1.e-5

    time_ = time + eps

    if (abs(time_ - int(time_/dt)*dt) < 2*eps) then
      divisible_by = .true.
    else
      divisible_by = .false.
    endif

  end function


  subroutine check_dt(dom, dt_sec, dt_cfl)

    use mod_parameter, only : nps, w_ss

    implicit none

    type(domain), intent(in) :: dom
    real, intent(in) :: dt_sec
    real, intent(out) :: dt_cfl

    integer :: i, k
    real :: uc_, wc_, dc_

    real, parameter :: eps_u=1.e-9, eps_d=1.e-9
    real :: dt_cx=1e9, dt_dx=1e9, dt_cz=1e9, dt_dz=1e9

    do i=1, dom%nx
      do k=dom%kc_bot(i), dom%k_srf
        uc_ = (dom%u(i-1,k) + dom%u(i,k))/2 + eps_u
        dc_ = dom%dmx(i,k) + eps_d
        dt_cx = min(dt_cx, dom%dx(i)/abs(uc_))
        dt_dx = min(dt_dx, dom%dx(i)**2/(2*dc_))

        wc_ = (dom%w(i,k-1) + dom%w(i,k) - w_ss(nps))/2 + eps_u
        dc_ = (dom%dmz(i,k-1) + dom%dmz(i,k))/2 + eps_d
        dt_cz = min(dt_cz, dom%dz(k)/abs(wc_))
        dt_dz = min(dt_dz, dom%dz(k)**2/(2*dc_))
      enddo
    enddo

    dt_cfl = min(dt_cx, dt_dx, dt_cz, dt_dz)

    if (dt_sec > dt_cfl) then
      print '(a,a)', 'Error: dt does not satisfy the CFL condition in domain ', &
        trim(dom%name)
      print '(a,4e10.3)', 'allowable dt limits: cx, dx, cz, dz =', &
        dt_cx, dt_dx, dt_cz, dt_dz
      stop
    endif

  end subroutine check_dt


  subroutine set_probe(dom)
    !
    ! inputs:  namelist.d01, ..
    ! outputs: n_prb, x_prb, z_prb, i_prb, k_prb
    !
    implicit none

    type(domain), intent(inout) :: dom

    integer :: i, j, k

    integer :: nx, nz
    real, pointer :: x(:), z(:)

    integer :: n_prb
    real :: x_prb(50)=-999., z_prb(50)=-999.
    namelist /probe/ n_prb, x_prb, z_prb

    !--- pointer ---
    nx=dom%nx; nz=dom%nz
    x=>dom%x; z=>dom%z
    !---------------

    ! loading from namelist file
    open(10, file=trim(dom%fname_nml), status='old')
    read(10, nml=probe)
    close(10)

    write(6, '(a)') trim(dom%name)
    write(6, nml=probe)

    allocate ( &
      dom%x_prb(n_prb), dom%z_prb(n_prb), &
      dom%i_prb(n_prb), dom%k_prb(n_prb))

    dom%n_prb = n_prb
    dom%x_prb = x_prb(1:n_prb)
    dom%z_prb = z_prb(1:n_prb)

    do j=1, n_prb

      dom%i_prb(j) = 0
      dom%k_prb(j) = 0

      do i=1, nx
        if (x(i-1) <= x_prb(j) .and. x_prb(j) <= x(i)) then
          dom%i_prb(j) = i
          exit
        endif
      enddo

      if (dom%z_prb(j) < -900.) then
        dom%k_prb(j) = dom%k_srf
      else
        do k=dom%kc_bot(i), dom%k_srf
          if (z(k-1) <= z_prb(j) .and. z_prb(j) <= z(k)) then
            dom%k_prb(j) = k
            exit
          endif
        enddo
      endif

      if (dom%i_prb(j)==0 .or. dom%k_prb(j)==0) then
        write (*,'(a)', advance='no') 'error: probing point is out of bounds, '
        write (*,'(a,a,i1)') trim(dom%name), ' point-', j
        print *, j, dom%x_prb(j), dom%z_prb(j)
        stop
      endif

    enddo

  end subroutine set_probe


  subroutine write_timeseries(dom, idom, it_snap, time_day)

    use mod_parameter, only : nps
#ifdef WQ
    use mod_parameter, only : nwq
#endif
#ifdef TRACER
    use mod_parameter, only : ntr, age
#endif

    implicit none

    type(domain), intent(in) :: dom
    integer, intent(in) :: idom, it_snap
    real, intent(in) :: time_day

    logical, save :: first_call(10)=.true.
    character(len=128) :: fname
    character(len=300) :: header 
    character(len=50), save :: &
      fmt, fmt_in, fmt_out, fmt_sed, fmt_cnf, fmt_wtp, fmt_pio, fmt_prb
    integer :: i, j, k, l
    real :: u_, w_
#ifdef WQ
    character(len=200), parameter :: header_wq = &
         ' O(g/m3) DC(g/m3) C(g/m3) SC(g/m3)' &
      // ' P(mg/m3) D(mg/m3) SP(mg/m3)' &
      // ' N(g/m3) E(g/m3) SN(g/m3)' &
      // ' Y1(mg/m3) Y2(mg/m3) Y3(mg/m3) Z(g/m3)'    
#endif

    if (first_call(idom)) then

      ! water body
      header = 'DAYS Z_SRF(m) W_SRF(m/s) TOTAL_VOL(m3)'
      write(fname, '(a,i3.3)') 'ts_waterbody.', it_snap
      fname = 'out/' // trim(dom%name) // '/' // trim(fname)
      open(100+idom, file=fname, status='unknown')
      write(100+idom, '(a)') trim(header)
      write(fmt, '(a)') '(4e15.7)'

      ! inflow
      header = 'DAYS Q(m3/s) T(deg-C)'
      do l=1, nps
        write(header(len_trim(header)+1:), '(a, "S", i1, "(g/m3)")') ' ', l
      enddo
#ifdef WQ
      header = trim(header) // trim(header_wq)
#endif
#ifdef TRACER
      do l=1, ntr
        if (age(l)) then
          write(header(len_trim(header)+1:), '(a, "TR", i1, "(days)")') ' ', l
        else
          write(header(len_trim(header)+1:), '(a, "TR", i1, "(-)")') ' ', l
        endif
      enddo
#endif
      write(fname, '(a,i3.3)') 'ts_inflow.', it_snap
      fname = 'out/' // trim(dom%name) // '/' // trim(fname)
      open(110+idom, file=fname, status='unknown')
      write(110+idom, '(a)') trim(header)
      write(fmt_in, '(a,i0,a)') '(3e15.7, ', nps, '(e15.7))'

      ! outflow
      header = 'DAYS Q(m3/s) T(deg-C)'
      do l=1, nps
         write(header(len_trim(header)+1:), '(a, "S", i1, "(g/m3)")') ' ', l
      enddo
#ifdef WQ
      header = trim(header) // trim(header_wq)
#endif
#ifdef TRACER
      do l=1, ntr
        if (age(l)) then
          write(header(len_trim(header)+1:), '(a, "TR", i1, "(days)")') ' ', l
        else
          write(header(len_trim(header)+1:), '(a, "TR", i1, "(-)")') ' ', l
        endif
      enddo
#endif
      write(fname, '(a,i3.3)') 'ts_outflow.', it_snap
      fname = 'out/' // trim(dom%name) // '/' // trim(fname)
      open(120+idom, file=fname, status='unknown')
      write(120+idom, '(a)') trim(header)
      write(fmt_out, '(a,i0,a)') '(3e15.7, ', nps, '(e15.7))'

      ! sedimentation
      header = 'DAYS '
      do l=1, nps
        write(header(len_trim(header)+1:), '(a, "S", i1, "(g/s)")') ' ', l
      enddo
      write(fname, '(a,i3.3)') 'ts_sediment.', it_snap
      fname = 'out/' // trim(dom%name) // '/' // trim(fname)
      open(130+idom, file=fname, status='unknown')
      write(130+idom, '(a)') trim(header)
      write(fmt_sed, '(a,i0,a)') '(3e15.7, ', nps, '(e15.7))'

      ! confluence
      if (dom%n_cnf > 0) then
        header = 'DAYS Q(m3/s) T(deg-C)'
        do l=1, nps
          write(header(len_trim(header)+1:), '(a, "S", i1, "(g/m3)")') ' ', l
        enddo
#ifdef WQ
      header = trim(header) // trim(header_wq)
#endif
#ifdef TRACER
        do l=1, ntr
          if (age(l)) then
            write(header(len_trim(header)+1:), '(a, "TR", i1, "(days)")') ' ', l
          else
            write(header(len_trim(header)+1:), '(a, "TR", i1, "(-)")') ' ', l
          endif
        enddo
#endif
        do j=1, dom%n_cnf
          write(fname, '(a,i0,a,i3.3)') 'ts_confluence.', j, '.', it_snap
          fname = 'out/' // trim(dom%name) // '/' // trim(fname)
          open(200+10*idom+j, file=fname, status='unknown')
          write(200+10*idom+j, '(a)') trim(header)
        enddo
        write(fmt_cnf, '(a,i0,a)') '(3e15.7, ', nps, '(e15.7))'
      endif

      ! water pipe
      if (dom%n_wtp > 0) then
        header = 'DAYS Q(m3/s) T(deg-C)'
        do l=1, nps
          write(header(len_trim(header)+1:), '(a, "S", i1, "(g/m3)")') ' ', l
        enddo
#ifdef WQ
      header = trim(header) // trim(header_wq)
#endif
#ifdef TRACER
        do l=1, ntr
          if (age(l)) then
            write(header(len_trim(header)+1:), '(a, "TR", i1, "(days)")') ' ', l
          else
            write(header(len_trim(header)+1:), '(a, "TR", i1, "(-)")') ' ', l
          endif
        enddo
#endif
        do j=1, dom%n_wtp
          write(fname, '(a,i0,a,i3.3)') 'ts_waterpipe.', j, '.', it_snap
          fname = 'out/' // trim(dom%name) // '/' // trim(fname)
          open(300+10*idom+j, file=fname, status='unknown')
          write(300+10*idom+j, '(a)') trim(header)
        enddo
         write(fmt_wtp, '(a,i0,a)') '(3e15.7, ', nps, '(e15.7))'
      endif

      ! point in-out
      if (dom%n_pio > 0) then
        header = 'DAYS Q(m3/s) T(deg-C)'
        do l=1, nps
          write(header(len_trim(header)+1:), '(a, "S", i1, "(g/m3)")') ' ', l
        enddo
#ifdef WQ
      header = trim(header) // trim(header_wq)
#endif
#ifdef TRACER
        do l=1, ntr
          if (age(l)) then
            write(header(len_trim(header)+1:), '(a, "TR", i1, "(days)")') ' ', l
          else
            write(header(len_trim(header)+1:), '(a, "TR", i1, "(-)")') ' ', l
          endif
        enddo
#endif
        do j=1, dom%n_pio
          write(fname, '(a,i0,a,i3.3)') 'ts_pointio.', j, '.', it_snap
          fname = 'out/' // trim(dom%name) // '/' // trim(fname)
          open(400+10*idom+j, file=fname, status='unknown')
          write(400+10*idom+j, '(a)') trim(header)
        enddo
         write(fmt_pio, '(a,i0,a)') '(3e15.7, ', nps, '(e15.7))'
      endif

      ! probe
      header = 'DAYS U(m/s) W(m/s) T(deg-C)'
      do l=1, nps
        write(header(len_trim(header)+1:), '(a, "S", i1, "(g/m3)")') ' ', l
      enddo
#ifdef WQ
      header = trim(header) // trim(header_wq)
#endif
#ifdef TRACER
      do l=1, ntr
        if (age(l)) then
          write(header(len_trim(header)+1:), '(a, "TR", i1, "(days)")') ' ', l
        else
          write(header(len_trim(header)+1:), '(a, "TR", i1, "(-)")') ' ', l
        endif
      enddo
#endif
      do j=1, dom%n_prb
        write(fname, '(a,i0,a,i3.3)') 'ts_probe.', j, '.', it_snap
        fname = 'out/' // trim(dom%name) // '/' // trim(fname)
        open(1000+100*idom+j, file=fname, status='unknown')
        write(1000+100*idom+j, '(a)') trim(header)
      enddo
      write(fmt_prb, '(a,i0,a)') '(4e15.7, ', nps, '(e15.7))'

      first_call(idom) = .false.
    endif

    ! water body
    write(100+idom, fmt) time_day, dom%z_srf, dom%w_srf, dom%total_vol

    ! inflow
    write(110+idom, fmt_in, advance='no') time_day, &
      dom%q_in, dom%t_in, (dom%s_in(l), l=1, nps)
#ifdef WQ
    do l=1, nwq
      write(110+idom, '(e15.7)', advance='no') dom%wq_in(l)
    enddo
#endif
#ifdef TRACER
    do l=1, ntr
      write(110+idom, '(e15.7)', advance='no') dom%tr_in(l)
    enddo
#endif
    write(110+idom, *)

    ! outflow
    write(120+idom, fmt_out, advance='no') time_day, &
      dom%qtot_out, dom%t_out, (dom%s_out(l), l=1, nps)
#ifdef WQ
    do l=1, nwq
      write(120+idom, '(e15.7)', advance='no') dom%wq_out(l)
    enddo
#endif
#ifdef TRACER
    do l=1, ntr
      write(120+idom, '(e15.7)', advance='no') dom%tr_out(l)
    enddo
#endif
    write(120+idom, *)

    ! sedimentation
    write(130+idom, fmt_sed, advance='no') time_day, &
      (sum(dom%s_sed(:,l)), l=1, nps)
#ifdef WQ
    do l=1, nwq
      write(130+idom, '(e15.7)', advance='no') sum(dom%wq_sed(:,l))
    enddo
#endif
    write(130+idom, *)

    ! confluence
    do j=1, dom%n_cnf
      write(200+10*idom+j, fmt_cnf, advance='no') time_day, &
        dom%q_cnfs(j), dom%t_cnfs(j), (dom%s_cnfs(j,l), l=1, nps)
#ifdef WQ
      do l=1, nwq
        write(200+10*idom+j, '(e15.7)', advance='no') dom%wq_cnfs(j,l)
      enddo
#endif
#ifdef TRACER
      do l=1, ntr
        write(200+10*idom+j, '(e15.7)', advance='no') dom%tr_cnfs(j,l)
      enddo
#endif
      write(200+10*idom+j, *)
    enddo

    ! water pipe
    do j=1, dom%n_wtp
      write(300+10*idom+j, fmt_wtp, advance='no') time_day, &
        dom%q_wtps(j), dom%t_wtps(j), (dom%s_wtps(j,l), l=1, nps)
#ifdef WQ
      do l=1, nwq
        write(300+10*idom+j, '(e15.7)', advance='no') dom%wq_wtps(j,l)
      enddo
#endif
#ifdef TRACER
      do l=1, ntr
        write(300+10*idom+j, '(e15.7)', advance='no') dom%tr_wtps(j,l)
      enddo
#endif
      write(300+10*idom+j, *)
    enddo

    ! point in-out
    do j=1, dom%n_pio
      write(400+10*idom+j, fmt_pio, advance='no') time_day, &
        dom%q_pios(j), dom%t_pios(j), (dom%s_pios(j,l), l=1, nps)
#ifdef WQ
      do l=1, nwq
        write(400+10*idom+j, '(e15.7)', advance='no') dom%wq_pios(j,l)
      enddo
#endif
#ifdef TRACER
      do l=1, ntr
        write(400+10*idom+j, '(e15.7)', advance='no') dom%tr_pios(j,l)
      enddo
#endif
      write(400+10*idom+j, *)
    enddo

    ! probe
    do j=1, dom%n_prb

      i = dom%i_prb(j)

      if (dom%z_prb(j) < -900.) then ! surface value
        k = dom%k_srf
      else
        k = dom%k_prb(j)
      endif

      if (k > dom%k_srf) then ! dry up
        write(1000+100*idom+j, fmt_prb, advance='no') time_day, &
          -999., -999., -999., (-999., l=1, nps)
#ifdef WQ
        do l=1, nwq
          write(1000+100*idom+j, '(e15.7)', advance='no') -999.
        enddo
#endif
#ifdef TRACER
        do l=1, ntr
          write(1000+100*idom+j, '(e15.7)', advance='no') -999.
        enddo
#endif
        write(1000+100*idom+j, *)
      else
        u_ = (dom%u(i-1,k) + dom%u(i,k))/2
        w_ = (dom%w(i,k-1) + dom%w(i,k))/2
        write(1000+100*idom+j, fmt_prb, advance='no') time_day, &
          u_, w_, dom%t(i,k), (dom%s(i,k,l), l=1, nps)
#ifdef WQ
        do l=1, nwq
          write(1000+100*idom+j, '(e15.7)', advance='no') dom%wq(i,k,l)
        enddo
#endif
#ifdef TRACER
        do l=1, ntr
          write(1000+100*idom+j, '(e15.7)', advance='no') dom%tr(i,k,l)
        enddo
#endif
        write(1000+100*idom+j, *)
      endif

    enddo

  end subroutine write_timeseries


  subroutine write_snap(dom, it_snap, time_day)
    !
    ! input  : it_snap, time_day, total_vol, z_srf, &
    !          k_srf, n_fnc, i_fncs, k_fncs, &
    !          u, w, t, s, wq, wq_sed, tr
    ! output : 'out/d01/snap.<it_snap>', ..
    !
    use mod_parameter, only : nps, d_ss
#ifdef WQ
    use mod_parameter, only : nwq
#endif
#ifdef TRACER
    use mod_parameter, only : ntr, age
#endif

    implicit none

    type(domain), intent(in) :: dom
    integer, intent(in) :: it_snap
    real, intent(in) :: time_day

    integer :: i, j, k, m, nx, nz
    character(len=128) :: fname, fmt

    write(fname, '(a,i3.3)') 'snap.', it_snap
    open(10, file='out/'//trim(dom%name)//'/'//trim(fname), status='unknown')

    write(10,'(3e15.7,30i5)') time_day, dom%total_vol, dom%z_srf, dom%k_srf, &
      dom%n_fnc, dom%i_fncs, ((dom%k_fncs(i,j),i=1,2),j=1,dom%n_fnc)

    write(10,'(i5,20e15.7)') nps, d_ss(1:nps)
#ifdef WQ
    write(10,'(i5)') nwq
#endif
#ifdef TRACER
    write(10,'(i5,20l2)') ntr, age(1:ntr)
#endif

    nx=dom%nx; nz=dom%nz
    m = nps  ! bug fix 2025/7/25
#ifdef WQ
    m = max(nps,nwq)
#endif
#ifdef TRACER
    m = max(m,ntr)
#endif
    write(fmt, '(a,i0,a)') '(', (nx+2)*(nz+2)*m, '(e15.7))'

    write(10,fmt) ((dom%u(i,k),i=0,nx),k=1,nz)
    write(10,fmt) ((dom%w(i,k),i=1,nx),k=0,nz)
    write(10,fmt) ((dom%rho(i,k),i=0,nx+1),k=0,nz+1)
    write(10,fmt) ((dom%p(i,k),i=0,nx+1),k=0,nz+1)
    write(10,fmt) ((dom%t(i,k),i=0,nx+1),k=0,nz+1)
    write(10,fmt) (((dom%s(i,k,j),i=0,nx+1),k=0,nz+1),j=1,nps)
    write(10,fmt) ((dom%s_sed(i,j),i=0,nx+1),j=1,nps)
#ifdef WQ
    write(10,fmt) (((dom%wq(i,k,j),i=0,nx+1),k=0,nz+1),j=1,nwq)
    write(10,fmt) ((dom%wq_sed(i,j),i=0,nx+1),j=1,nwq)
#endif
#ifdef TRACER
    write(10,fmt) (((dom%tr(i,k,j),i=0,nx+1),k=0,nz+1),j=1,ntr)
#endif

    close(10)

  end subroutine write_snap


  subroutine read_snap(dom, it_snap, time_day)
    !
    ! input  : it_snap, "out/snap.<it_snap>", ..
    ! outout : time_day, total_vol, z_srf, k_srf, n_fnc, i_fncs, k_fncs, 
    !          u, w, t, s
    !
    use mod_parameter, only : nps, d_ss
#ifdef WQ
    use mod_parameter, only : nwq
#endif
#ifdef TRACER
    use mod_parameter, only : ntr, age
#endif

    implicit none

    type(domain), intent(inout) :: dom
    integer, intent(in) :: it_snap
    real, intent(out) :: time_day

    character(len=128) :: fname

    write(fname, '(a,i3.3)') 'snap.', it_snap
    open(10, file='out/'//trim(dom%name)//'/'//trim(fname), status='unknown')

    read(10,*) time_day, dom%total_vol, dom%z_srf, dom%k_srf!, &
!      dom%n_fnc, dom%i_fncs, dom%k_fncs

    read(10,*) nps, d_ss(1:nps)
#ifdef WQ
    read(10,*) nwq
#endif
#ifdef TRACER
    read(10,*) ntr, age(1:ntr)
#endif

    read(10,*) dom%u
    read(10,*) dom%w
    read(10,*) dom%rho
    read(10,*) dom%p
    read(10,*) dom%t
    read(10,*) dom%s
    read(10,*) dom%s_sed
#ifdef WQ
    read(10,*) dom%wq
    read(10,*) dom%wq_sed
#endif
#ifdef TRACER
    read(10,*) dom%tr
#endif

    close(10)

  end subroutine read_snap

end module mod_utility


module mod_momentum

  implicit none

  logical :: pressure_grad=.false.  ! impose(T) or expose(F) pressure gradient

contains

  subroutine set_momentum()

    implicit none

    ! namelist
    namelist /momentum/ pressure_grad

    ! loading from namelist file
    open(10, file='namelist.in', status='old')
    read(10, nml=momentum)
    close(10)

    write(6, nml=momentum)

  end subroutine set_momentum


  subroutine update_momentum(dom, dt_sec)
    !
    ! inputs:  u, w, dmx, dmz, dt_sec
    ! outputs: u, w
    !
    use mod_parameter, only : rho_water
    use mod_domain, only : domain

    implicit none

    type(domain), intent(inout) :: dom
    real, intent(in) :: dt_sec

    integer :: nx, nz, k_srf
    integer, pointer, dimension(:) :: k_bot, kc_bot
    real, pointer, dimension(:) :: dx, dzs
    real, pointer, dimension(:,:) :: au, aw, aus, aws, vols
    real, pointer, dimension(:,:) :: rho, p, dmx, dmz

    integer :: i, j, k
    real :: rhs, fp, fm, fxm, fxp, fzm, fzp, q_col_
    real, allocatable :: u(:,:), w(:,:)

    !--- pointer, allocation ----------------------------
    nx=dom%nx; nz=dom%nz
    k_bot=>dom%k_bot; kc_bot=>dom%kc_bot; k_srf=dom%k_srf
    dx=>dom%dx; dzs=>dom%dzs
    rho=>dom%rho; p=>dom%p; dmx=>dom%dmx; dmz=>dom%dmz
    au=>dom%au; aw=>dom%aw; aus=>dom%aus; aws=>dom%aws; vols=>dom%vols
    allocate (u(0:nx,nz), w(nx,0:nz))
    !----------------------------------------------------

    u=dom%u;  w=dom%w

    do i=1, nx-1
      do k=k_bot(i), k_srf

        ! advection-x
        fm = (u(i-1,k) + u(i,k))/2*dom%aus(i,k)
        if (fm >= 0.0) then
          fm = fm*u(i-1,k)
        else
          fm = fm*u(i,k)
        endif

        fp = (u(i,k) + u(i+1,k))/2*dom%aus(i+1,k)
        if (fp >= 0.0) then
          fp = fp*u(i,k)
        else
          fp = fp*u(i+1,k)
        endif

        fxm = -fm
        fxp = -fp

        ! advection-z
        fm = (w(i,k-1) + w(i+1,k-1))/2*aws(i,k-1)
        if (k == k_bot(i)) then
          fm = fm*0.0
        else
          if (fm >= 0.0) then
            fm = fm*u(i,k-1)
          else
            fm = fm*u(i,k)
          endif
        endif

        fp = (w(i,k) + w(i+1,k))/2*aws(i,k)
        if (k == k_srf) then
          fp = fp*u(i,k)
        else
          if (fp >= 0.0) then
            fp = fp*u(i,k)
          else
            fp = fp*u(i,k+1)
          endif
        endif

        fzm = -fm
        fzp = -fp

        ! diffusion-x
        fm = dmx(i,k)*(u(i,k) - u(i-1,k))/dx(i)*aus(i,k)
        fp = dmx(i+1,k)*(u(i+1,k) - u(i,k))/dx(i)*aus(i+1,k)

        fxm = fxm + fm
        fxp = fxp + fp

        ! diffusion-z
        if (k == k_bot(i)) then
          fm = 0.0
        else
          fm = dmz(i,k-1)*(u(i,k) - u(i,k-1))/dzs(k-1)*aws(i,k-1)
        endif

        if (k == k_srf) then
          fp = 0.0
        else
          fp = dmz(i,k)*(u(i,k+1) - u(i,k))/dzs(k)*aws(i,k)
        endif

        fzm = fzm + fm
        fzp = fzp + fp

        ! right hand side term
        rhs = fxp - fxm + fzp - fzm

        ! pressure gradient
        if (pressure_grad) &
          rhs = rhs - (p(i+1,k) - p(i,k))/dom%dxs(i)/rho_water*vols(i,k)

        ! confluence
        if (dom%n_cnf > 0) then
          if (dom%u_cnf(i,k) >= 0.) rhs = rhs + dom%u_cnf(i,k)*dom%q_cnf(i,k)
          if (dom%u_cnf(i+1,k) < 0.) rhs = rhs + dom%u_cnf(i+1,k)*dom%q_cnf(i+1,k)
        endif

        ! water pipe
        if (dom%n_wtp > 0) then
          if (dom%u_wtp(i,k) >= 0.) rhs = rhs + dom%u_wtp(i,k)*dom%q_wtp(i,k)
          if (dom%u_wtp(i+1,k) < 0.) rhs = rhs + dom%u_wtp(i+1,k)*dom%q_wtp(i+1,k)
        endif

        ! point in-out
        if (dom%n_pio > 0) then
          if (dom%u_pio(i,k) >= 0.) rhs = rhs + dom%u_pio(i,k)*dom%q_pio(i,k)
          if (dom%u_pio(i+1,k) < 0.) rhs = rhs + dom%u_pio(i+1,k)*dom%q_pio(i+1,k)
        endif

        ! new u
        dom%u(i,k) = u(i,k) + dt_sec*rhs/vols(i,k)

      enddo
    enddo

    ! fence
    do j=1, dom%n_fnc
      dom%u(dom%i_fncs(j),dom%k_fncs(1,j):dom%k_fncs(2,j)) = 0.0
    enddo

    ! impose continuity on each column
    if (.not. pressure_grad) then
    do i=1, nx-1
      q_col_ = 1e-10
      do k=k_bot(i), k_srf
        q_col_ = q_col_ + au(i,k)*dom%u(i,k)
      enddo
      do k=k_bot(i), k_srf
        dom%u(i,k) = dom%u(i,k)*abs(dom%q_col(i)/q_col_)
      enddo
    enddo
    endif

    ! new w by continuity eq.
    do i=1, nx
      dom%w(i,kc_bot(i)-1) = 0.0
      do k=kc_bot(i), k_srf-1
        dom%w(i,k) = ( &
          dom%q_cnf(i,k) + dom%q_wtp(i,k) + dom%q_pio(i,k) + &
          dom%w(i,k-1)*aw(i,k-1) - &
          dom%u(i,k)*au(i,k) + dom%u(i-1,k)*au(i-1,k)) / aw(i,k)
      enddo
      dom%w(i,k_srf) = dom%w_srf
    enddo

    ! ghost cell
    if (k_srf < nz) then
      do i=1, nx
        dom%u(i,k_srf+1) = dom%u(i,k_srf)
        dom%w(i,k_srf+1) = dom%w(i,k_srf)
      enddo
    endif

    deallocate (u, w)

  end subroutine update_momentum

end module mod_momentum


module mod_heat

  use mod_timeseries, only : timeseries, timeseries_read, timeseries_interp
  use mod_parameter, only : psat, rho_water, c_water, l_vapor, k_boltzmann

  implicit none

  logical :: &
    radiation=.true.  ! include(T) or exclude(F) solar radiation and SHX

  real ::         &
    ar=0.06,      &   ! refraction rate of solar radiation on water surface
    beta=0.5,     &   ! absorption parameter [0.4:0.6]
    eta=0.5,      &   ! light extinction parameter [0.3:1.5]
    z_wind=1.0,   &   ! measured height of wind speed, m
    coeff_solar=1.0   ! tuning coeff. of solar radiation, -

  real, parameter :: &
    z0=1.e-4          ! roughness length at water surface, m

  character(len=128) :: &
    fname_meteo=''    ! meteorological data file

  type(timeseries) :: &
    ts_meteo          ! time series of met data

  real ::  &
    time,  &          ! days
    solar, &          ! solar radiation, kcal/m2/day
    cloud, &          ! cloud coverage, [0:1]
    t_air, &          ! air temperature, deg-C
    rh,    &          ! relative humidity, [0:1]
    wind,  &          ! wind speed at z_wind, m/s
    rain              ! precipitation, mm/hour

contains

  subroutine set_heat()

    implicit none

    ! namelist (heat)
    namelist /heat/ radiation, ar, beta, eta, z_wind, coeff_solar, fname_meteo

    ! loading from namelist file
    open(10, file='namelist.in', status='old')
    read(10, nml=heat)
    close(10)

    write(6, nml=heat)

    ! setup meteorological data
    call timeseries_read(fname_meteo, ts_meteo)

  end subroutine set_heat


  subroutine update_meteorology(time_day)

    implicit none
    real, intent(in) :: time_day
    real, allocatable :: array(:)

    allocate (array(ts_meteo%nv))

    call timeseries_interp(ts_meteo, time_day, array)

    solar = array(1)    ! solar radiation, kcal/m2/day
    cloud = array(2)    ! cloud coverage, [0:1]
    t_air = array(3)    ! air temperature, deg-C
    rh    = array(4)    ! relative humidity, [0:1]
    wind  = array(5)    ! wind speed at z_wind, m/s
    rain  = array(6)    ! precipitation, mm/hour

    deallocate (array)

  end subroutine update_meteorology


  real function surface_heat_flux(t_srf)
    ! water surface heat echange, Km/s
    implicit none

    real, intent(in) :: t_srf ! water surface temperatrure, deg-C
    real :: phi_0, phi_s, phi_ec, phi_ra, tmp, ts, ta
    real :: ce0, cc0, ce, cc, s, w, w2

    ! evaporation and conduction (Rohwer's eq.)
    tmp = psat(t_srf) - rh*psat(t_air)

    if (.true.) then

      ! Rohwer's eq.
      w = wind * log(0.15/z0)/log(z_wind/z0)  ! wind speed at 0.15m

      phi_ec = (3.08e-4 + 1.85e-4*w*0.635)*rho_water &
        * (tmp*(l_vapor + (c_water-0.54)*t_srf) + 269.1*(t_srf - t_air))

    else

      ! Kondo's eq.
      w = wind * log(10./z0)/log(z_wind/z0)  ! wind speed at 10m
      w2 = w**2

      ce0 = 1.49
      cc0 = 1.43
      if (0.3 <= w .and. w < 2.3) then
        ce0 = 1.230*w**(-0.160)
        cc0 = 1.185*w**(-0.157)
      else if (2.3 <= w .and. w < 5.0) then
        ce0 = 0.969 + 0.0521*w
        cc0 = 0.927 + 0.0546*w
      else if (5.0 <= w .and. w < 8.0) then
        ce0 = 1.18 + 0.01*w
        cc0 = 1.15 + 0.01*w
      else if (8.0 <= w) then
        ce0 = 1.170 + 0.0144*w - 0.004*w2
        cc0 = 1.141 + 0.0147*w - 0.00045*w2
      endif

      if (abs(t_srf - t_air) < 1.e-3) then
        ce = ce0
        cc = cc0
      else
        ! stability parameter, s
        if (w > 0.0) then
          s = (t_srf - t_air)/w2/(1.0 + 0.01+w2/abs(t_srf - t_air))
        else
          s = 100*(t_srf - t_air)
        endif
        if (s < 0.) then ! unstable
          if (-3.3 < s) then
            ce = ce0*(0.1 + 0.03*s + 0.9*exp(4.8*s))
            cc = cc0*(0.1 + 0.03*s + 0.9*exp(4.8*s))
          else
            ce = 0.0
            cc = 0.0
          endif
        else
          ce = ce0*(1.0 + 0.63+sqrt(s))
          cc = cc0*(1.0 + 0.63+sqrt(s))
        endif
      endif
      
      phi_ec = 50.33*ce*tmp*w + 24.88*cc*(t_srf - t_air)*w

    endif

    if (tmp < 0.0) phi_ec = 0.0

    ! atmospheric radiation (Swinbank's eq.)
    ts = t_srf + 273.15
    ta = t_air + 273.15
    phi_ra = 0.97*k_boltzmann*(ts**4 - 0.937e-5*ta**6*(1.+0.17*cloud**2))

    ! solar radiation, kcal/m2/day
    phi_0 = coeff_solar*(1.0 - ar)*solar

    ! water surface heat exchange, kcal/m2/day
    phi_s = phi_0 - (phi_ec + phi_ra)

    ! kcal/m2/day --> Km/s
    surface_heat_flux = phi_s/(rho_water*c_water)/(3600*24)

  end function surface_heat_flux


  real function radiation_heat_flux(depth)
    ! radiation heat flux in water body, Km/s
    implicit none

    real, intent(in) :: depth ! water depth, m
    real :: phi_0, phi

    ! penetration of solar radiation, kcal/m2/day
    phi_0 = coeff_solar*(1.0 - ar)*solar

    ! heat flux in water
    phi = (1.0 - beta)*phi_0*exp(-eta*depth)

    ! kcal/m2/day --> Km/s
    radiation_heat_flux = phi/(rho_water*c_water)/(3600*24)

  end function radiation_heat_flux


  subroutine update_heat(dom, dt_sec)
    !
    ! inputs:  t, u, w, dhx, dhz, dt_sec
    ! outputs: t
    !
    use mod_domain, only : domain
    
    implicit none

    type(domain), intent(inout) :: dom
    real, intent(in) :: dt_sec

    integer :: nx, nz, k_srf
    integer, pointer, dimension(:) :: k_bot, kc_bot
    real, pointer, dimension(:) :: dxs, dzs
    real, pointer, dimension(:,:) :: u, w, dhx, dhz
    real, pointer, dimension(:,:) :: au, aw, vol

    integer :: i, j, k
    real :: fm, fp, fxm, fxp, fzm, fzp, rhs
    real, allocatable :: t(:,:)

    !--- pointer, allocation ----------------------------
    nx=dom%nx; nz=dom%nz
    k_bot=>dom%k_bot; kc_bot=>dom%kc_bot; k_srf=dom%k_srf
    dxs=>dom%dxs; dzs=>dom%dzs
    u=>dom%u; w=>dom%w; dhx=>dom%dhx; dhz=>dom%dhz
    au=>dom%au; aw=>dom%aw; vol=>dom%vol
    allocate (t(0:nx+1,0:nz+1))
    !----------------------------------------------------

    t=dom%t

    do i=1, nx
      do k=kc_bot(i), k_srf

        ! advection-x
        fm = u(i-1,k)*au(i-1,k)
        if (fm > 0.0) then
          fm = fm*t(i-1,k)
        else
          fm = fm*t(i,k)
        endif

        fp = u(i,k)*au(i,k)
        if (fp > 0.0) then
          fp = fp*t(i,k)
        else
          fp = fp*t(i+1,k)
        endif

        fxm = -fm
        fxp = -fp

        ! advection-z
        fm = w(i,k-1)*aw(i,k-1)
        if (k == kc_bot(i)) then
          fm = fm*0.0
        else
          if (fm > 0.0) then
            fm = fm*t(i,k-1)
          else
            fm = fm*t(i,k)
          endif
        endif

        fp = w(i,k)*aw(i,k)
        if (k == k_srf) then
          fp = fp*t(i,k)
        else
          if (fp > 0.0) then
            fp = fp*t(i,k)
          else
            fp = fp*t(i,k+1)
          endif
        endif

        fzm = -fm
        fzp = -fp

        ! diffusion-x
        if (i == 1 .or. k <= k_bot(i-1)) then
          fm = 0.0
        else
          fm = dhx(i-1,k)*(t(i,k) - t(i-1,k))/dxs(i-1)*au(i-1,k)
        endif

        if (i == nx .or. k <= k_bot(i)) then
          fp = 0.0
        else
          fp = dhx(i,k)*(t(i+1,k) - t(i,k))/dxs(i)*au(i,k)
        endif

        fxm = fxm + fm
        fxp = fxp + fp

        ! diffusion-z
        if (k == kc_bot(i)) then
          fm = 0.0
        else
          fm = dhz(i,k-1)*(t(i,k) - t(i,k-1))/dzs(k-1)*aw(i,k-1)
        endif

        if (k == k_srf) then
          fp = 0.0
        else
          fp = dhz(i,k)*(t(i,k+1) - t(i,k))/dzs(k)*aw(i,k)
        endif

        ! radiation heat flux
        if (radiation) then
          fm = fm + radiation_heat_flux(dom%z_srf - dom%z(k-1))*aw(i,k-1)
          if (k == k_srf) then
            fp = fp + surface_heat_flux(t(i,k_srf))*aw(i,k)
          else
           fp = fp + radiation_heat_flux(dom%z_srf - dom%z(k))*aw(i,k)
          endif
       endif

        fzm = fzm + fm
        fzp = fzp + fp

        ! fence
        do j=1, dom%n_fnc
          if (dom%k_fncs(1,j) <= k .and. k <= dom%k_fncs(2,j)) then
            if (i-1 == dom%i_fncs(j)) fxm = 0.0
            if (i == dom%i_fncs(j)) fxp = 0.0
          endif
        enddo

        ! right hand side term
        rhs = fxp - fxm + fzp - fzm

        ! confluence
        if (dom%n_cnf > 0) then
          if (dom%q_cnf(i,k) >= 0.) then
            rhs = rhs + dom%t_cnf(i,k)*dom%q_cnf(i,k)
          else
            rhs = rhs + t(i,k)*dom%q_cnf(i,k)
          endif
        endif

        ! water pipe
        if (dom%n_wtp > 0) then
          if (dom%q_wtp(i,k) >= 0.) then
            rhs = rhs + dom%t_wtp(i,k)*dom%q_wtp(i,k)
          else
            rhs = rhs + t(i,k)*dom%q_wtp(i,k)
          endif
        endif

        ! point in-out
        if (dom%n_pio > 0) then
          if (dom%q_pio(i,k) >= 0.) then
            rhs = rhs + dom%t_pio(i,k)*dom%q_pio(i,k)
          else
            rhs = rhs + t(i,k)*dom%q_pio(i,k)
          endif
        endif
#ifndef V1D
        ! divergence correction
        if (k == k_srf) &
          rhs = rhs + (u(i,k)*au(i,k) - u(i-1,k)*au(i-1,k) &
            + w(i,k)*aw(i,k) - w(i,k-1)*aw(i,k-1))*t(i,k)        
#endif
        ! new t
        dom%t(i,k) = t(i,k) + dt_sec*rhs/vol(i,k)

      enddo
    enddo

    ! ghost cell
    if (k_srf < nz) then
      do i=1, nx
        dom%t(i,k_srf+1) = dom%t(i,k_srf)
      enddo
    endif

    deallocate (t)

  end subroutine update_heat

end module mod_heat


module mod_suspended_solids

  implicit none

contains

  subroutine set_suspended_solids()

    use mod_parameter, only : gravity, rho_water, mu_water, &
      nps, rho_ss, d_ss, w_ss

    implicit none

    ! namelist (particle)
    real :: particle_size(20)=0.0   ! particle size for each bins, m
    namelist /particle/ nps, particle_size, rho_ss

    integer :: l
    real :: rep

    ! loading from namelist file
    open(10, file='namelist.in', status='old')
    read(10, nml=particle)
    close(10)

    write(6, nml=particle)

    ! particle size, settling velocity(Stokes' law) 
    ! and particle Reynolds number
    allocate (d_ss(nps), w_ss(nps))

    do l=1, nps

      d_ss(l) = particle_size(l)
      w_ss(l) = gravity*(rho_ss - rho_water)*d_ss(l)**2/(18*mu_water)

      rep = w_ss(l)*d_ss(l)*rho_water/mu_water ! particle Re
      if (rep > 1.5) then
        print *, 'Error: particle Reynolds number is too large, Rep=', rep
        stop
      endif

    enddo

  end subroutine set_suspended_solids


  subroutine update_suspended_solids(dom, dt_sec)
    !
    ! inputs:  s, u, w, dcx, dcz, dt_sec
    ! outputs: s, s_sed
    !
    use mod_parameter, only : nps, w_ss
    use mod_domain, only : domain
    
    implicit none

    type(domain), intent(inout) :: dom
    real, intent(in) :: dt_sec

    integer :: nx, nz, k_srf
    integer, pointer, dimension(:) :: k_bot, kc_bot
    real, pointer, dimension(:) :: dxs, dzs
    real, pointer, dimension(:,:) :: u, w, dcx, dcz
    real, pointer, dimension(:,:) :: au, aw, vol

    integer :: i, j, k, l
    real :: fm, fp, fxm, fxp, fzm, fzp, rhs
    real, allocatable :: s(:,:,:)

    !--- pointer, allocation -----------------------------
    nx=dom%nx; nz=dom%nz
    k_bot=>dom%k_bot; kc_bot=>dom%kc_bot; k_srf=dom%k_srf
    dxs=>dom%dxs; dzs=>dom%dzs; dcx=>dom%dcx; dcz=>dom%dcz
    u=>dom%u; w=>dom%w
    au=>dom%au; aw=>dom%aw; vol=>dom%vol
    allocate (s(0:nx+1,0:nz+1,nps))
    !----------------------------------------------------

    s = dom%s
    dom%s_sed = 0.0  ! deposition of suspended solids, g/s

    do l=1, nps  ! particle-size loop

    do i=1, nx
      do k=kc_bot(i), k_srf

        ! advection-x
        fm = u(i-1,k)*au(i-1,k)
        if (fm > 0.0) then
          fm = fm*s(i-1,k,l)
        else
          fm = fm*s(i,k,l)
        endif

        fp = u(i,k)*au(i,k)
        if (fp > 0.0) then
          fp = fp*s(i,k,l)
        else
          fp = fp*s(i+1,k,l)
        endif

        fxm = -fm
        fxp = -fp

        ! advection-z
        fm = (w(i,k-1) - w_ss(l))*aw(i,k-1)
        if (k == kc_bot(i)) then
          fm = fm*s(i,k,l)
          dom%s_sed(i,l) = dom%s_sed(i,l) - fm ! sedimentation rate, g/s
        else
          if (fm > 0.0) then
            fm = fm*s(i,k-1,l)
          else
            fm = fm*s(i,k,l)
          endif
        endif

        if (k == k_srf) then
          fp = w(i,k)*aw(i,k)*s(i,k,l)
        else
          fp = (w(i,k) - w_ss(l))*aw(i,k)
          if (fp > 0.0) then
            fp = fp*s(i,k,l)
          else
            fp = fp*s(i,k+1,l)
          endif
        endif

        fzm = -fm
        fzp = -fp

        ! diffusion-x
        if (i == 1 .or. k <= k_bot(i-1)) then
          fm = 0.0
        else
          fm = dcx(i-1,k)*(s(i,k,l) - s(i-1,k,l))/dxs(i-1)*au(i-1,k)
        endif

        if (i == nx .or. k <= k_bot(i)) then
          fp = 0.0
        else
          fp = dcx(i,k)*(s(i+1,k,l) - s(i,k,l))/dxs(i)*au(i,k)
        endif

        fxm = fxm + fm
        fxp = fxp + fp

        ! diffusion-z
        if (k == kc_bot(i)) then
          fm = 0.0
        else
          fm = dcz(i,k-1)*(s(i,k,l) - s(i,k-1,l))/dzs(k-1)*aw(i,k-1)
        endif

        if (k == k_srf) then
          fp = 0.0
        else
          fp = dcz(i,k)*(s(i,k+1,l) - s(i,k,l))/dzs(k)*aw(i,k)
        endif

        fzm = fzm + fm
        fzp = fzp + fp

        ! fence
        do j=1, dom%n_fnc
          if (dom%k_fncs(1,j) <= k .and. k <= dom%k_fncs(2,j)) then
            if (i-1 == dom%i_fncs(j)) fxm = 0.0
            if (i == dom%i_fncs(j)) fxp = 0.0
          endif
        enddo

        ! right hand side term
        rhs = fxp - fxm + fzp - fzm

        ! confluence
        if (dom%n_cnf > 0) then
          if (dom%q_cnf(i,k) >= 0.) then
            rhs = rhs + dom%s_cnf(i,k,l)*dom%q_cnf(i,k)
          else
            rhs = rhs + s(i,k,l)*dom%q_cnf(i,k)
          endif
        endif

        ! water pipe
        if (dom%n_wtp > 0) then
          if (dom%q_wtp(i,k) >= 0.) then
            rhs = rhs + dom%s_wtp(i,k,l)*dom%q_wtp(i,k)
          else
            rhs = rhs + s(i,k,l)*dom%q_wtp(i,k)
          endif
        endif

        ! point in-out
        if (dom%n_pio > 0) then
          if (dom%q_pio(i,k) >= 0.) then
            rhs = rhs + dom%s_pio(i,k,l)*dom%q_pio(i,k)
          else
            rhs = rhs + s(i,k,l)*dom%q_pio(i,k)
          endif
        endif
#ifndef V1D
        ! divergence correction
        if (k == k_srf) &
          rhs = rhs + (u(i,k)*au(i,k) - u(i-1,k)*au(i-1,k) &
            + w(i,k)*aw(i,k) - w(i,k-1)*aw(i,k-1))*s(i,k,l)
#endif
        ! new s
        dom%s(i,k,l) = s(i,k,l) + dt_sec*rhs/vol(i,k)

      enddo
    enddo

    ! ghost cell
    if (k_srf < nz) then
      do i=1, nx
        dom%s(i,k_srf+1,l) = dom%s(i,k_srf,l)
      enddo
    endif

    enddo  ! particle-size loop

    deallocate (s)

  end subroutine update_suspended_solids

end module mod_suspended_solids


#ifdef WQ

module mod_waterquality

  implicit none

  real, parameter :: &
    day = 3600.*24,  & ! sec/day
    i_s = 3000.        ! optimum solar radiation, kcal/m2/day

  real :: &
    g_ymax20(3), &  ! max growth rate at 20 deg-C, 1/day
    k_i,         &  ! radiation half-saturation constant, kcal/m2/day
    k_p(3),      &  ! phosphorus(P) half-saturation constant, mgP/m3
    k_n(3),      &  ! nitrogen(N) half-saturation constant, gN/m3
    r_y20,       &  ! phytoplankton(Y) respiration rate, 1/day
    c_g20,       &  ! zooplankton(Z) filtration rate, m3/gC/day
    r_z20,       &  ! Z respiration rate, 1/day
    a_s,         &  ! Y max assimilation rate, -
    k_y,         &  ! Y assimilation half-saturation constant, mgChl/m3
    d_z,         &  ! Z mortality rate, 1/day
    gamma_y,     &  ! Y return rate, -
    gamma_z,     &  ! Z return rate, -
    k_d20,       &  ! lake-derived(L-D) organic phosphorus(OP) degradation rate, 1/day
    k_sp20,      &  ! river-derived(R-D) OP degradation rate, 1/day
    k_e20,       &  ! L-D organic nitrogen(ON) degradation rate, 1/day
    k_sn20,      &  ! R-D OP degradation rate, 1/day
    k_c20,       &  ! L-D COD degradation rate, 1/day
    k_sc,        &  ! R-D COD degradation rate, 1/day
    w_y(3),      &  ! phytoplankton settling velocity, m/day
    w_d,         &  ! L-D OP settling velocity, m/day
    w_e,         &  ! L-D ON settling velocity, m/day
    w_c,         &  ! L-D detritus COD(C) settling velocity, m/day
    w_sp,        &  ! R-D OP settling velocity, m/day
    w_sn,        &  ! R-D ON settling velocity, m/day
    w_sc,        &  ! R-D C settling velocity, m/day
    w_p,         &  ! P elution rate from sediment, mgP/m2/day
    w_n,         &  ! N elution rate from sediment, gN/m2/day
    w_o,         &  ! oxygen(O) consumption rate by sediment, gO2/m2/day
    sigma_ny,    &  ! conv. factor for P to N, gN/mgChl
    sigma_nz,    &  ! conv. factor for Z to N, gN/gC
    sigma_py,    &  ! conv. factor for phytoplankton to P, mgP/mgChl
    sigma_pz,    &  ! conv. factor for zooplankton to P, mgP/gC
    sigma_oy,    &  ! conv. factor for DO production by P, gO2/mgChl
    sigma_oz,    &  ! conv. factor for DO consumption by Z, gO2/gC
    sigma_od,    &  ! conv. factor for DO due to degradation of L-D OP, gO2/mgP
    sigma_sp,    &  ! conv. factor for DO due to degradation of R-D OP, gO2/mgP
    sigma_cy,    &  ! conv. factor for Y to COD, gCOD/mgChl
    sigma_cz,    &  ! conv. factor for Z to COD, gCOD/gC
    sigma_cs,    &  ! conv. factor for river turbidity to COD, gCOD/gC
    sigma_zy,    &  ! conv. factor for Y to Z, gC/mgChl
    theta_ry,    &  ! constant, -
    theta_cg,    &  ! constant, -
    theta_rz,    &  ! constant, -
    theta_kd,    &  ! constant, -
    theta_sp,    &  ! constant, -
    theta_ke,    &  ! constant, -
    theta_ksn,   &  ! constant, -
    theta_kc        ! constant, -

contains

  subroutine set_waterquality()

    implicit none

    ! namelist (waterquality)
    namelist /waterquality/ &
      g_ymax20, k_i, k_p, k_n, r_y20, c_g20, r_z20, a_s, k_y, d_z, &
      gamma_y, gamma_z, k_d20, k_sp20, k_e20, k_sn20, k_c20, k_sc, &
      w_y, w_d, w_e, w_c, w_sp, w_sn, w_sc, w_p, w_n, w_o, &
      sigma_ny, sigma_nz, sigma_py, sigma_pz, sigma_oy, sigma_oz, &
      sigma_od, sigma_sp, sigma_cy, sigma_cz, sigma_cs, sigma_zy, &
      theta_ry, theta_cg, theta_rz, theta_kd, theta_sp, theta_ke, &
      theta_ksn, theta_kc

    ! default params
!    g_ymax20 = (/1., 1.6, 1./)
    g_ymax20 = (/1.8, 2.5, 2.5/)*3
    k_i = 860.;  k_p = (/1., 5., 5./);  k_n = (/0.1, 0.1, 0.1/)
    r_y20 = 0.01 ! 0.05
    theta_ry = 1.045

    c_g20 = 1.2/2 !1.2
    a_s = 0.7;  k_y = 60.
    r_z20 = 0.01 !0.04
    d_z = 0.075

    gamma_y = 0.2 ! 0.5
    gamma_z = 0.2 ! 0.5
    
    k_d20 = 0.02  ! 0.1
    k_sp20 = 0.02 ! 0.1
    k_e20 = 0.02
    k_sn20 = 0.02
    k_c20 = 0.12
    k_sc = 0.

    theta_kd = 1.08;  theta_sp = 1.08;  theta_ke = 1.08
    theta_ksn = 1.08;  theta_kc = 1.08

    w_y = (/0., 0.05, 0.05/)
    w_d = 0.1;  w_e = 0.1;  w_c = 0.1
    w_sp = 0.1;  w_sn = 0.1;  w_sc = 0.1
    w_p = 0.;  w_n = 0.012
    w_o = 0.9*3; !0.9

    sigma_ny = 0.019;  sigma_nz = 0.8
    sigma_py = 1.1;  sigma_pz = 100.
    sigma_oy = 0.13;  sigma_oz = 14.2;  sigma_od = 0.142
    sigma_sp = 0.142;  sigma_cy = 0.074;  sigma_cz = 2.;  sigma_cs = 0.11
    sigma_zy = 0.05

    theta_cg = 1.08;  theta_rz = 1.08

    ! loading from namelist file
    open(10, file='namelist.in', status='old')
    read(10, nml=waterquality)
    close(10)

    write(6, nml=waterquality)

    ! per day to per second
    g_ymax20 = g_ymax20/day
    r_y20 = r_y20/day;  c_g20 = c_g20/day;  r_z20 = r_z20/day;  d_z = d_z/day
    
    k_d20 = k_d20/day;  k_sp20 = k_sp20/day;  k_e20 = k_e20/day
    k_sn20 = k_sn20/day;  k_c20 = k_c20/day;  k_sc = k_sc/day

    w_y = w_y/day
    w_d = w_d/day;  w_e = w_e/day;  w_c = w_c/day
    w_sp = w_sp/day;  w_sn = w_sn/day;  w_sc = w_sc/day
    w_p = w_p/day;  w_n = w_n/day;  w_o = w_o/day

  end subroutine set_waterquality


  real function surface_oxygen_flux(o, t)
    !
    ! water surface O2 exchange
    !
    use mod_heat, only : z0, z_wind, wind ! wind speed, m/s
    implicit none

    real, intent(in) :: o, t ! water surface DO(g/m3) and temperatrure(deg-C)
    real, parameter :: &
      w_0 = 2.0,       &     ! reference wind speed, m/s
      l_f0 = 440.e-6         ! reference surface film thickness, m
    real :: alpha_m, l_f, k_g, w, o_sat

    ! molecular diffusivity of DO, m2/day
    alpha_m = 1.760e-4*1.037**(t - 20.)

    ! depth of surface film, m
    w = wind * log(0.1/z0)/log(z_wind/z0)  ! wind speed at 10cm
    if (w >= 2.) then
      l_f = l_f0/(w/w_0)**2
    else
      l_f = l_f0
    endif

    ! exchange coefficient, m/s
    k_g = (alpha_m/l_f)/day

    ! saturation dissolved oxygen, g/m3
    o_sat = 0.665*(760. - 5.03*exp(0.062*t))/(t + 35.)

    ! surface O2 flux, g/m2/s
    surface_oxygen_flux = k_g*(o_sat - o)

  end function surface_oxygen_flux


  subroutine calc_wq(l, wq, t, depth, aov, rhs)
    !
    ! inputs: l, wq, t
    ! outputs: rhs
    !
    use mod_parameter, only : nwq, rho_water, c_water
    use mod_heat, only : radiation_heat_flux

    implicit none

    integer, intent(in) :: l
    real, intent(in) :: wq(nwq), t, depth, aov
    real, intent(out) :: rhs

    integer :: i
    real :: o, dc, c, sc, p, d, sp, n, e, sn, y(3), z, yy
    real :: f_t(3), ii, f_i, f_e(3), g_y(3), r_y, d_y, f_y(3), g_z, r_z, &
      k_c, k_d, k_sp, k_e, k_sn
    real :: i_m, i_p

    o  = wq(1)  ! dissolved oxygen, g/m3
    dc = wq(2)  ! dissolved COD, g/m3
    c  = wq(3)  ! detritus COD, g/m3
    sc = wq(4)  ! river-derived suspended COD, mg/m3
    p  = wq(5)  ! phosphate phosphorus, mg/m3
    d  = wq(6)  ! detritus phosphorus, mg/m3
    sp = wq(7)  ! river-derived organic phosphorus, mg/m3
    n  = wq(8)  ! inorganic nitrogen, g/m3
    e  = wq(9)  ! detritus nitrogen, g/m3
    sn = wq(10) ! river-derived organic nitrogen, g/m3
    y(1:3) = wq(11:13)  ! phytoplankton, mgChl/m3
    z = wq(14)  ! zooplankton, g/m3

    yy = sum(y) ! total phytoplankton, mg/m3

    ! function of temperature, -
    f_t(1) = (t/25.*exp(1. - t/25.))**3
    f_t(2) = 1. - ((t - 15.)/15.)**2
    f_t(3) = (t/20.*exp(1. - t/20.))**3

    ! function of radiation, -
    ii = radiation_heat_flux(depth)*(rho_water*c_water)*day  ! kcal/m2/day
    f_i = ii/(k_i + ii)

    ! function of phosphorus and nitrogen, -
    do i=1, 3
      f_e(i) = min(p/(k_p(i) + p), n/(k_n(i) + n))
    enddo

    ! phytoplankton growth rate, 1/sec
    g_y(:) = g_ymax20(:)*f_t(:)*f_i*f_e(:)

    ! phytoplankton respiration rate, 1/sec
    r_y = r_y20*theta_ry**(t - 20.)

    ! predation rate by zooplankton, 1/sec
    d_y = c_g20*theta_cg**(t - 20.)*z

    ! zooplankton growth rate, 1/sec
    f_y(:) = a_s*k_y/(k_y + y(:))
    g_z = sigma_zy*c_g20*theta_cg**(t - 20.)*sum(f_y(:)*y(:))

    ! zooplankton respiration rate, 1/sec
    r_z = r_z20*theta_rz**(t - 20.)

    ! degradation rate, 1/day
    k_c  = k_c20*theta_kc**(t - 20.)
    k_d  = k_d20*theta_kd**(t - 20.)
    k_sp = k_sp20*theta_sp**(t - 20.)
    k_e  = k_e20*theta_ke**(t - 20.)
    k_sn = k_sn20*theta_ksn**(t - 20.)

    if (l==1) then       ! O  (DO)    dissolved oxygen
      rhs = &
          sigma_oy*sum(g_y(:)*y(:)) &
        - sigma_oy*r_y*yy &
        - sigma_oz*r_z*z &
        - sigma_od*k_d*d &
        - sigma_sp*k_sp*sp &
        - w_o*aov

    else if (l==2) then  ! DC (D-COD) dissolved COD
      rhs = 0.

    else if (l==3) then  ! C  (C-COD) detritus COD
      rhs = &
          sigma_cy*r_y*yy &
        + sigma_cy*sum((1. - f_y(:))*d_y*y(:)) &
        + sigma_cz*(r_z + d_z)*z &
        - k_c*c

    else if (l==4) then  ! SC (S-COD) river-derived suspended COD
      rhs = -k_sc*sc

    else if (l==5) then  ! P  (I-P)   phosphate phosphorus
      rhs = &
        - sigma_py*sum(g_y(:)*y(:)) &
        + sigma_py*sum(gamma_y*r_y*y(:)) &
        + sigma_pz*gamma_z*r_z*z &
        + k_d*d &
        + k_sp*sp &
        + w_p*aov

    else if (l==6) then  ! D  (O-P)   detritus phosrhorus
      rhs = &
          sigma_py*(1. - gamma_y)*r_y*yy &
        + sigma_pz*(1. - gamma_z)*r_z*z &
        + sigma_py*sum((1. - f_y(:))*d_y*y(:)) &
        + sigma_pz*d_z*z &
        - k_d*d

    else if (l==7) then  ! SP (O-SP)  river-derived organic phosrhorus
      rhs = -k_sp*sp

    else if (l==8) then  ! N  (I-N)   inorganic nitrogen
      rhs = &
        - sigma_ny*sum(g_y(:)*y(:)) &
        + sigma_ny*gamma_y*r_y*yy &
        + sigma_nz*gamma_z*r_z*z &
        + k_e*e &
        + k_sn*sn &
        + w_n*aov

    else if (l==9) then  ! E  (O-N)   detritus nitrogen
      rhs = &
          sigma_ny*(1. - gamma_y)*r_y*yy &
        + sigma_nz*(1. - gamma_z)*r_z*z &
        + sigma_ny*sum((1. - f_y(:))*d_y*y(:)) &
        + sigma_nz*k_d*z &
        - k_e*e

    else if (l==10) then ! SN (O-SN)  river-derived organic nitrogen
      rhs = -k_sn*sn

    else if (l==11) then ! Y1 (Y1)    phytoplankton-1
      rhs = (g_y(1) - r_y - d_y)*y(1)

    else if (l==12) then ! Y2 (Y2)    phytoplankton-2
      rhs = (g_y(2) - r_y - d_y)*y(2)

    else if (l==13) then ! Y3 (Y3)    phytoplankton-3
      rhs = (g_y(3) - r_y - d_y)*y(3)

    else if (l==14) then ! Z  (Z)     zooplankton
      rhs = (g_z - r_z - d_z)*z

    endif

  end subroutine calc_wq


  subroutine update_waterquality(dom, dt_sec)
    !
    ! inputs:  wq, u, w, dcx, dcz, dt_sec
    ! outputs: wq, wq_sed
    !
    use mod_parameter, only : nwq
    use mod_domain, only : domain

    implicit none

    type(domain), intent(inout) :: dom
    real, intent(in) :: dt_sec

    integer :: nx, nz, k_srf
    integer, pointer, dimension(:) :: k_bot, kc_bot
    real, pointer, dimension(:) :: dxs, dzs
    real, pointer, dimension(:,:) :: u, w, dcx, dcz
    real, pointer, dimension(:,:) :: au, aw, vol

    integer :: i, j, k, l
    real :: fm, fp, fxm, fxp, fzm, fzp, rhs, rhs_wq, w_wq, depth, aov
    real, allocatable :: wq(:,:,:)

    !--- pointer, allocation -----------------------------
    nx=dom%nx; nz=dom%nz
    k_bot=>dom%k_bot; kc_bot=>dom%kc_bot; k_srf=dom%k_srf
    dxs=>dom%dxs; dzs=>dom%dzs
    u=>dom%u; w=>dom%w; dcx=>dom%dcx; dcz=>dom%dcz
    au=>dom%au; aw=>dom%aw; vol=>dom%vol
    allocate (wq(0:nx+1,0:nz+1,nwq))
    !----------------------------------------------------

    wq=dom%wq
    dom%wq_sed=0.  ! sedimentation rate, g/s or mg/s (Y, D, E, C)

    do l=1, nwq  ! water qualities loop

    if (l==3) then       ! C
      w_wq = w_c
    else if (l==4) then  ! SC
      w_wq = w_sc
    else if (l==6) then  ! D
      w_wq = w_d
    else if (l==7) then  ! SP
      w_wq = w_sp
    else if (l==9) then  ! E
      w_wq = w_e
    else if (l==10) then ! SN
      w_wq = w_sn
    else if (l==11) then ! Y1
      w_wq = w_y(1)
    else if (l==12) then ! Y2
      w_wq = w_y(2)
    else if (l==13) then ! Y3
      w_wq = w_y(3)
    else
      w_wq = 0.
    endif

    do i=1, nx
      do k=kc_bot(i), k_srf

        ! advection-x
        fm = u(i-1,k)*au(i-1,k)
        if (fm > 0.0) then
          fm = fm*wq(i-1,k,l)
        else
          fm = fm*wq(i,k,l)
        endif

        fp = u(i,k)*au(i,k)
        if (fp > 0.0) then
          fp = fp*wq(i,k,l)
        else
          fp = fp*wq(i+1,k,l)
        endif

        fxm = -fm
        fxp = -fp

        ! advection-z
        fm = (w(i,k-1) - w_wq)*aw(i,k-1)
        if (k == kc_bot(i)) then
          fm = fm*wq(i,k,l)
          dom%wq_sed(i,l) = dom%wq_sed(i,l) - fm
        else
          if (fm > 0.0) then
            fm = fm*wq(i,k-1,l)
          else
            fm = fm*wq(i,k,l)
          endif
        endif

        if (k == k_srf) then
          fp = w(i,k)*aw(i,k)*wq(i,k,l)
          if (l==1) &
            fp = fp - aw(i,k)*surface_oxygen_flux(wq(i,k,l), dom%t(i,k))
        else
          fp = (w(i,k) - w_wq)*aw(i,k)
          if (fp > 0.0) then
            fp = fp*wq(i,k,l)
          else
            fp = fp*wq(i,k+1,l)
          endif
        endif

        fzm = -fm
        fzp = -fp

        ! diffusion-x
        if (i == 1 .or. k <= k_bot(i-1)) then
          fm = 0.
        else
          fm = dcx(i-1,k)*(wq(i,k,l) - wq(i-1,k,l))/dxs(i-1)*au(i-1,k)
        endif

        if (i == nx .or. k <= k_bot(i)) then
          fp = 0.
        else
          fp = dcx(i,k)*(wq(i+1,k,l) - wq(i,k,l))/dxs(i)*au(i,k)
        endif

        fxm = fxm + fm
        fxp = fxp + fp

        ! diffusion-z
        if (k == kc_bot(i)) then
          fm = 0.
        else
          fm = dcz(i,k-1)*(wq(i,k,l) - wq(i,k-1,l))/dzs(k-1)*aw(i,k-1)
        endif

        if (k == k_srf) then
          fp = 0.
        else
          fp = dcz(i,k)*(wq(i,k+1,l) - wq(i,k,l))/dzs(k)*aw(i,k)
        endif

        fzm = fzm + fm
        fzp = fzp + fp

        ! fence
        do j=1, dom%n_fnc
          if (dom%k_fncs(1,j) <= k .and. k <= dom%k_fncs(2,j)) then
            if (i-1 == dom%i_fncs(j)) fxm = 0.
            if (i == dom%i_fncs(j)) fxp = 0.
          endif
        enddo

        ! right hand side term
        rhs = fxp - fxm + fzp - fzm

        ! confluence
        if (dom%n_cnf > 0) then
          if (dom%q_cnf(i,k) >= 0.) then
            rhs = rhs + dom%wq_cnf(i,k,l)*dom%q_cnf(i,k)
          else
            rhs = rhs + wq(i,k,l)*dom%q_cnf(i,k)
          endif
        endif

        ! water pipe
        if (dom%n_wtp > 0) then
          if (dom%q_wtp(i,k) >= 0.) then
            rhs = rhs + dom%wq_wtp(i,k,l)*dom%q_wtp(i,k)
          else
            rhs = rhs + wq(i,k,l)*dom%q_wtp(i,k)
          endif
        endif

        ! point in-out
        if (dom%n_pio > 0) then
          if (dom%q_pio(i,k) >= 0.) then
            rhs = rhs + dom%wq_pio(i,k,l)*dom%q_pio(i,k)
          else
            rhs = rhs + wq(i,k,l)*dom%q_pio(i,k)
          endif
        endif

        ! source term
        depth = dom%z_srf - dom%zc(k)
        aov = max(aw(i,k) - aw(i,k-1), 0.)/vol(i,k)
        call calc_wq(l, wq(i,k,:), dom%t(i,k), depth, aov, rhs_wq)
        rhs = rhs + rhs_wq*vol(i,k)

#ifndef V1D
        ! divergence correction
        if (k == k_srf) then
          rhs = rhs + (u(i,k)*au(i,k) - u(i-1,k)*au(i-1,k) &
            + w(i,k)*aw(i,k) - w(i,k-1)*aw(i,k-1))*wq(i,k,l)
        endif
#endif
        ! new fields
        dom%wq(i,k,l) = wq(i,k,l) + dt_sec*rhs/vol(i,k)
        dom%wq(i,k,l) = max(dom%wq(i,k,l), 0.)

      enddo
    enddo

    ! ghost cell
    if (k_srf < nz) then
      do i=1, nx
        dom%wq(i,k_srf+1,l) = dom%wq(i,k_srf,l)
      enddo
    endif

    dom%wq(:,k_srf+2:nz+1,l) = 0.

    do i=1, nx
      dom%wq(i,0:kc_bot(i)-1,l) = 0.
    enddo

    enddo  ! water qualities loop

    deallocate (wq)

  end subroutine update_waterquality

end module mod_waterquality

#endif


#ifdef TRACER

module mod_tracer

  implicit none

contains

  subroutine set_tracer()

    use mod_parameter, only : ntr, age

    implicit none

    logical :: water_age(10)=.false.
    namelist /tracer/ ntr, water_age

    integer :: l

    ! loading from namelist file
    open(10, file='namelist.in', status='old')
    read(10, nml=tracer)
    close(10)

    write(6, nml=tracer)

    allocate (age(ntr))

    do l=1, ntr
      age(l) = water_age(l)
    enddo

  end subroutine set_tracer


  subroutine update_tracer(dom, dt_sec)
    !
    ! inputs:  tr, u, w, dcx, dcz, dt_sec
    ! outputs: tr
    !
    use mod_parameter, only : ntr, age
    use mod_domain, only : domain
    
    implicit none

    type(domain), intent(inout) :: dom
    real, intent(in) :: dt_sec

    integer :: nx, nz, k_srf
    integer, pointer, dimension(:) :: k_bot, kc_bot
    real, pointer, dimension(:) :: dxs, dzs
    real, pointer, dimension(:,:) :: u, w, dcx, dcz
    real, pointer, dimension(:,:) :: au, aw, vol

    integer :: i, j, k, l
    real :: fm, fp, fxm, fxp, fzm, fzp, rhs
    real, allocatable :: tr(:,:,:)

    !--- pointer, allocation -----------------------------
    nx=dom%nx; nz=dom%nz
    k_bot=>dom%k_bot; kc_bot=>dom%kc_bot; k_srf=dom%k_srf
    dxs=>dom%dxs; dzs=>dom%dzs
    u=>dom%u; w=>dom%w; dcx=>dom%dcx; dcz=>dom%dcz
    au=>dom%au; aw=>dom%aw; vol=>dom%vol
    allocate (tr(0:nx+1,0:nz+1,ntr))
    !----------------------------------------------------

    tr = dom%tr

    do l=1, ntr  ! tracer loop

    do i=1, nx
      do k=kc_bot(i), k_srf

        ! advection-x
        fm = u(i-1,k)*au(i-1,k)
        if (fm > 0.0) then
          fm = fm*tr(i-1,k,l)
        else
          fm = fm*tr(i,k,l)
        endif

        fp = u(i,k)*au(i,k)
        if (fp > 0.0) then
          fp = fp*tr(i,k,l)
        else
          fp = fp*tr(i+1,k,l)
        endif

        fxm = -fm
        fxp = -fp

        ! advection-z
        fm = w(i,k-1)*aw(i,k-1)
        if (k == kc_bot(i)) then
          fm = fm*0.0
        else
          if (fm > 0.0) then
            fm = fm*tr(i,k-1,l)
          else
            fm = fm*tr(i,k,l)
          endif
        endif

        fp = w(i,k)*aw(i,k)
        if (k == k_srf) then
          fp = fp*tr(i,k,l)
        else
          if (fp > 0.0) then
            fp = fp*tr(i,k,l)
          else
            fp = fp*tr(i,k+1,l)
          endif
        endif

        fzm = -fm
        fzp = -fp

        ! diffusion-x
        if (i == 1 .or. k <= k_bot(i-1)) then
          fm = 0.0
        else
          fm = dcx(i-1,k)*(tr(i,k,l) - tr(i-1,k,l))/dxs(i-1)*au(i-1,k)
        endif

        if (i == nx .or. k <= k_bot(i)) then
          fp = 0.0
        else
          fp = dcx(i,k)*(tr(i+1,k,l) - tr(i,k,l))/dxs(i)*au(i,k)
        endif

        fxm = fxm + fm
        fxp = fxp + fp

        ! diffusion-z
        if (k == kc_bot(i)) then
          fm = 0.0
        else
          fm = dcz(i,k-1)*(tr(i,k,l) - tr(i,k-1,l))/dzs(k-1)*aw(i,k-1)
        endif

        if (k == k_srf) then
          fp = 0.0
        else
          fp = dcz(i,k)*(tr(i,k+1,l) - tr(i,k,l))/dzs(k)*aw(i,k)
        endif

        fzm = fzm + fm
        fzp = fzp + fp

        ! fence
        do j=1, dom%n_fnc
          if (dom%k_fncs(1,j) <= k .and. k <= dom%k_fncs(2,j)) then
            if (i-1 == dom%i_fncs(j)) fxm = 0.0
            if (i == dom%i_fncs(j)) fxp = 0.0
          endif
        enddo

        ! right hand side term
        rhs = fxp - fxm + fzp - fzm

        ! confluence
        if (dom%n_cnf > 0) then
          if (dom%q_cnf(i,k) >= 0.) then
            rhs = rhs + dom%tr_cnf(i,k,l)*dom%q_cnf(i,k)
          else
            rhs = rhs + tr(i,k,l)*dom%q_cnf(i,k)
          endif
        endif

        ! water pipe
        if (dom%n_wtp > 0) then
          if (dom%q_wtp(i,k) >= 0.) then
            rhs = rhs + dom%tr_wtp(i,k,l)*dom%q_wtp(i,k)
          else
            rhs = rhs + tr(i,k,l)*dom%q_wtp(i,k)
          endif
        endif

        ! point in-out
        if (dom%n_pio > 0) then
          if (dom%q_pio(i,k) >= 0.) then
            rhs = rhs + dom%tr_pio(i,k,l)*dom%q_pio(i,k)
          else
            rhs = rhs + tr(i,k,l)*dom%q_pio(i,k)
          endif
        endif
#ifndef V1D
        ! divergence correction
        if (k == k_srf) &
          rhs = rhs + (u(i,k)*au(i,k) - u(i-1,k)*au(i-1,k) &
            + w(i,k)*aw(i,k) - w(i,k-1)*aw(i,k-1))*tr(i,k,l)
#endif
        ! time generator for age estimation, m3/days
        if (age(l)) rhs = rhs + vol(i,k)/(3600*24)

        ! new s
        dom%tr(i,k,l) = tr(i,k,l) + dt_sec*rhs/vol(i,k)

      enddo
    enddo

    ! ghost cell
    if (k_srf < nz) then
      do i=1, nx
        dom%tr(i,k_srf+1,l) = dom%tr(i,k_srf,l)
      enddo
    endif

    enddo  ! tracer loop

    deallocate (tr)

  end subroutine update_tracer

end module mod_tracer

#endif


program main

  use mod_domain, only : domain, &
    doms, &
    set_geometry, allocate_variables, deallocate_variables, &
    set_initial, update_surface_layer, update_density, &
    set_turbulence, update_turbulence, write_geo

  use mod_boundary, only : set_boundary, update_boundary, &
    update_surface, deallocate_boundary

  use mod_heat, only : set_heat, update_meteorology, update_heat, radiation

  use mod_momentum, only : set_momentum, update_momentum

  use mod_suspended_solids, only : set_suspended_solids, update_suspended_solids

  use mod_utility, only : check_dt, set_probe, write_timeseries, &
    read_snap, write_snap, divisible_by
#ifdef WQ
  use mod_waterquality, only : set_waterquality, update_waterquality
#endif
#ifdef TRACER
  use mod_tracer, only : set_tracer, update_tracer
#endif

  implicit none

  type(domain), pointer :: dom

  ! namelist (control)
  integer :: ndom             ! number of domains
  character(len=128) :: names(10)='' ! name for each domains
  logical :: restart=.false.  ! restart(T) or cold start(F)
  integer :: it_rst=10        ! restart file number
  logical :: fixed_dt=.true.  ! fixed(T) or Variable(F) time step
  real    :: dt_sec_init=10.  ! initial dt, s
  real    :: dt_sec=10.       ! dt, s
  real    :: t_max=10.        ! integration periode, days
  real    :: t_out_fld=1.     ! output periode of 2d field, days
  real    :: t_out_ts=0.1     ! output periode of timeseries, days

  namelist /control/ ndom, names, restart, it_rst, &
    fixed_dt, dt_sec_init, t_max, t_out_fld, t_out_ts

  ! misc
  integer :: i, it_snap
  real :: time_day, dt_cfl
integer :: nx, nz

  ! loading from namelist file
  open(10, file='namelist.in', status='old')
  read(10, nml=control)
  close(10)

  dt_sec = dt_sec_init

  write(6, nml=control)

  ! allocate domains
  allocate (doms(ndom))

  ! read namelist params
  do i=1, ndom
    doms(i)%id = i
    doms(i)%name = trim(names(i))
    doms(i)%fname_nml = trim('namelist' // '.' // doms(i)%name)
  enddo

  ! setupd geometry data (grid, bed, width, volume, ..)
  do i=1, ndom
    call set_geometry(doms(i))
  enddo

  ! setup momentum, heat, suspended solids and water quality eq.
  call set_momentum
  call set_heat
  call set_suspended_solids
#ifdef WQ
  call set_waterquality
#endif
#ifdef TRACER
  call set_tracer
#endif

  ! allocate field variables
  do i=1, ndom
    call allocate_variables(doms(i))
  enddo

  ! initialization
  if (restart) then
    it_snap = it_rst
    do i=1, ndom
      call read_snap(doms(i), it_snap, time_day)
    enddo
  else
    time_day = 0.0
    it_snap = 0
    do i=1, ndom
      call set_initial(doms(i))
    enddo
  endif

  do i=1, ndom
    call set_boundary(doms(i))
  enddo

  do i=1, ndom
    dom => doms(i)
    call update_density(dom)
    call update_boundary(dom, time_day)
    call set_turbulence(dom)
    call update_turbulence(dom)
    call set_probe(doms(i))
  enddo

  call update_surface(ndom, dt_sec)

  do i=1, ndom
    dom => doms(i)
    call write_geo(dom)
    if (.not. restart) call write_snap(dom, it_snap, time_day)
    call write_timeseries(dom, i, it_snap, time_day)
  enddo

  ! std log
  write(6,'(a)')
  write(6,'(a)',advance='no') 'days, dom1:z_srf z_in del_in maxT maxC'
  if (ndom > 1) then
    write(6,'(a)') ', dom2:z_srf z_in del_in maxT maxC'
  else
    write(6,*) ''
  endif

  write(6,'(a)') 'days O DC C SC P D SP N E SN Y Z'

  write(6,'(f6.1,a,5f6.1)', advance='no') time_day, ', ', &
    doms(1)%z_srf, doms(1)%z_in, doms(1)%delta_in*2, &
    maxval(doms(1)%t), maxval(sum(doms(1)%s,dim=3))
  if (ndom > 1) &
    write(6,'(a,5f5.1)') ', ', &
      doms(2)%z_srf, doms(2)%z_in, doms(2)%delta_in*2, &
      maxval(doms(2)%t), maxval(sum(doms(2)%s,dim=3))

!      dom => doms(1)
!      nx = dom%nx
!      nz = dom%nz
!      write(6,'(13f6.2)') time_day, &
!        (maxval(dom%wq(1:nx,1:nz,i)), i=1, 10), &
!        maxval(dom%wq(1:nx,1:nz,11) + dom%wq(1:nx,1:nz,12) + dom%wq(1:nx,1:nz,13)), &
!        maxval(dom%wq(1:nx,1:nz,14))

  ! time loop
  do while (time_day <= t_max)

    do i=1, ndom
      call check_dt(doms(i), dt_sec, dt_cfl)
    enddo

    time_day = time_day + dt_sec/(3600*24)

    ! update meteorological data
    if (radiation) call update_meteorology(time_day)

    ! boundary conditions
    do i=1, ndom
      call update_boundary(doms(i), time_day)
    enddo

    ! update water surface
    call update_surface(ndom, dt_sec)

    ! primary variables
    do i=1, ndom
      dom => doms(i)
      call update_momentum(dom, dt_sec)
      call update_heat(dom, dt_sec)
      call update_suspended_solids(dom, dt_sec)
#ifdef WQ
      call update_waterquality(dom, dt_sec)
#endif
#ifdef TRACER
      call update_tracer(dom, dt_sec)
#endif
    enddo

    ! model variables
    do i=1, ndom
      call update_density(doms(i))
      call update_turbulence(doms(i))
    enddo

    ! output 2d field
    if (divisible_by(time_day+0.5, t_out_fld)) then

      it_snap = it_snap + 1
      do i=1, ndom
        call write_snap(doms(i), it_snap, time_day)
      enddo

      ! std log
!      dom => doms(1)
!      write(6,'(13f6.2)') time_day, &
!        (maxval(dom%wq(1:nx,1:nz,i)), i=1, 10), &
!        maxval(dom%wq(1:nx,1:nz,11) + dom%wq(1:nx,1:nz,12) + dom%wq(1:nx,1:nz,13)), &
!        maxval(dom%wq(1:nx,1:nz,14))
    endif

    ! output timeseries
    if (divisible_by(time_day, t_out_ts)) then
      do i=1, ndom
        call write_timeseries(doms(i), i, it_snap, time_day)
      enddo
    endif

  enddo

  ! deallocate arrays
  do i=1, ndom
    call deallocate_boundary(doms(i))
    call deallocate_variables(doms(i))
  enddo

  deallocate (doms)

  print *, 'finish normaly'

end program main
